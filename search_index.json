[["index.html", "Basic Reservoir Engineering in Python 1 License", " Basic Reservoir Engineering in Python Pramod Azad 1 License This work is licensed under a Creative Commons Attribution 4.0 International License. Copyright Citation BibTex If you use this repository for a certain purpose, please make this citation BibTex registry: @misc{pramodazad, author = {Pramod Azad}, title = {Basic Reservoir Engineering in Python}, year = {2021}, publisher = {GitHub}, journal = {GitHub repository}, } "],["introduction.html", "2 Introduction 2.1 Getting Started with Python 2.2 Lists 2.3 List comprehensions 2.4 Tuples 2.5 Dictionaries 2.6 Set", " 2 Introduction 2.1 Getting Started with Python Python is a widely used high-level programming language for general-purpose programming, created by Guido van Rossum and first released in 1991. Python features a dynamic type system and automatic memory management and supports multiple programming paradigms, including object-oriented, imperative, functional programming, and procedural styles. It has a large and comprehensive standard library You can download and install either version of Python here Verify if Python is installed $python --version If you have Python 3 installed, and it is your default version you should see something like this: $ python --version Python 3.6.0 Creating variables and assigning values To create a variable in Python, all you need to do is specify the variable name, and then assign a value to it. # Integer a = 2 print(a) # Output: 2 # Floating point pi = 3.14 print(pi) # Output: 3.14 # String c = &#39;A&#39; print(c) # Output: A You can not use pythons keywords as a valid variable name. You can see the list of keyword by: import keyword print(keyword.kwlist) Even though theres no need to specify a data type when declaring a variable in Python, while allocating the necessary area in memory for the variable, the Python interpreter automatically picks the most suitable built-in type for it: type() function can be used to determine the type of a given variable. a = 2 print(type(a)) # Output: &lt;type &#39;int&#39;&gt; Comments and Documentation Single line, inline and multiline comments - Single line comment: # This is a single line comment in Python Inline comment: used in same line as program. # is used to comment print(&quot;Hello World&quot;) # This line prints &quot;Hello World&quot; Multiline comment: &quot;&quot;&quot; This type of comment spans multiple lines. These are mostly used for documentation of functions, classes and modules. &quot;&quot;&quot; Block Indentation Python uses indentation to define control and loop constructs. This contributes to Pythons readability. Python uses the colon symbol (:) and indentation for showing where blocks of code begin and end. That is, blocks in Python, such as functions, loops, if clauses and other constructs, have no ending identifiers. All blocks start with a colon and then contain the indented lines below it. For example: def my_function(): # This is a function definition. Note the colon (:) a = 2 # This line belongs to the function because it&#39;s indented return a # This line also belongs to the same function print(my_function()) # This line is OUTSIDE the function block 2.1.1 Datatypes Built-in Types Booleans bool: A boolean value of either True or False. Logical operations like and, or, not can be performed on booleans. x or y # if x is False then y otherwise x x and y # if x is False then x otherwise y not x # if x is True then False, otherwise True Numbers int: Integer number a = 2 b = 100 float: Floating point number a = 2.0 b = 100.e0 complex: Complex numbers a = 2 + 1j b = 100 + 10j Strings str(&#39;hello&#39;) Sequences and collections tuple : An ordered collection of n values of any type. tuple supports indexing; immutable; hashable if all its members are hashable. list : An ordered collection of n values of any type. list are Not hashable; mutable. set: An unordered collection of unique values. Items must be hashable. dict: An unordered collection of unique key-value pairs; keys must be hashable. An object is hashable if it has a hash value which never changes during its lifetime. and can be compared to other objects. a = (1, 2, 3) # example of tuple. () bracket is used to create tuple b = (&#39;a&#39;, 1, &#39;python&#39;, (1, 2)) # example of tuple, multiple data type allowed b[2] = &#39;something else&#39; # returns a TypeError. This is not allowed a = [1, 2, 3] # example of list. [] bracket is used to create list b = [&#39;a&#39;, 1, &#39;python&#39;, (1, 2), [1, 2]] # example of list, multiple data type allowed b[2] = &#39;something else&#39; # allowed a = {1, 2, &#39;a&#39;} # example of set. {} bracket is used to create set. only unique values allowed a = {1: &#39;one&#39;, 2: &#39;two&#39;} # example of dict. b = {&#39;a&#39;: [1, 2, 3], &#39;b&#39;: &#39;a string&#39;} Collection Types There are a number of collection types in Python. While types such as int and str hold a single value, collection types hold multiple values. 2.2 Lists The list type is probably the most commonly used collection type in Python. Despite its name, a list is more like an array in other languages, mostly JavaScript. In Python, a list is merely an ordered collection of valid Python values. A list can be created by enclosing values, separated by commas, in square brackets: int_list = [1, 2, 3] string_list = [&#39;abc&#39;, &#39;defgh&#39;] # A list can be empty: empty_list = [] The elements of a list are not restricted to a single data type. A list can also contain another list as its element: mixed_list = [1, &#39;abc&#39;, True, 2.34, None] nested_list = [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3]] The elements of a list can be accessed via an index, or numeric representation of their position. Lists in Python are zero-indexed meaning that the first element in the list is at index 0, the second element is at index 1 and so on. Indices can also be negative which means counting from the end of the list (-1 being the index of the last element). names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;] print(names[0]) # Alice print(names[2]) # Craig print(names[-1]) # Eric print(names[-4]) # Bob Lists allow to use slice notation as lst[start:end:step]. The output of the slice notation is a new list containing elements from index start to end-1. If options are omitted start defaults to beginning of list, end to end of list and step to 1: lst = [1, 2, 3, 4] lst[1:] # [2, 3, 4] lst[:3] # [1, 2, 3] lst[::2] # [1, 3] lst[::-1] # [4, 3, 2, 1] lst[-1:0:-1] # [4, 3, 2] lst[5:8] # [] since starting index is greater than length of lst, returns empty list lst[1:10] # [2, 3, 4] since ending index is greater than length of lst, omit ending index lst[3:1:-1] # [4, 3] index(value, [startIndex])  gets the index of the first occurrence of the input value. If the input value is not in the list a ValueError exception is raised. If a second argument is provided, the search is started at that specified index. a = [1, 2, 3, 4, 5, 6, 7, 7] a.index(7) # Returns: 6 a.index(49) # ValueError, because 49 is not in a. a.index(7, 7) # Returns: 7 a.index(7, 8) # ValueError, because there is no 7 starting at index 8 Lists are mutable, so you can change the values in a list. Besides, it is possible to add and/or remove elements from a list. Append object to end of list with List.append(object). Add a new element to list at a specific index. List.insert(index, object). Remove the first occurrence of a value with List.remove(value) names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;] names[0] = &#39;Ann&#39; print(names) # Outputs [&#39;Ann&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;] names.append(&quot;Sia&quot;) print(names) # Outputs [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;, &#39;Sia&#39;] names.insert(1, &quot;Nikki&quot;) print(names) # Outputs [&#39;Alice&#39;, &#39;Nikki&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;, &#39;Sia&#39;] names.remove(&quot;Bob&quot;) print(names) # Outputs [&#39;Alice&#39;, &#39;Nikki&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;, &#39;Sia&#39;] Note that the append() method only appends one new element to the end of the list. If you append a list to another list, the list that you append becomes a single element at the end of the first list. # Appending a list to another list a = [1, 2, 3, 4, 5, 6, 7, 7] b = [8, 9] a.append(b) # a: [1, 2, 3, 4, 5, 6, 7, 7, [8, 9]] a[8] # Returns: [8,9] if you want to add all element of one list to other list. you have to extends the list by appending elements from another enumerable. a = [1, 2, 3, 4, 5, 6, 7, 7] b = [8, 9, 10] # Extend list by appending all elements from b a.extend(b) # a: [1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10] # Extend list with elements from a non-list enumerable: a.extend(range(3)) # a: [1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10, 0, 1, 2] Lists can also be concatenated with the + operator. Note that this does not modify any of the original lists rather create a new list. a = [1, 2, 3, 4, 5, 6] + [7, 7] + b # a: [1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10] Common function of list Get the index in the list of the first item whose value is x. name.index(&quot;Alice&quot;) # Output 0 # length of list len(names) # Output 6 count occurrence of any item in list a = [1, 1, 1, 2, 3, 4] a.count(1) 3 # Reverse the list a.reverse() [4, 3, 2, 1, 1, 1] # or a[::-1] [4, 3, 2, 1, 1, 1] pop([index])  removes and returns the item at index. With no argument it removes and returns the last element of the list. it is important to note that it removes the item from the list. names.pop() # Outputs &#39;Sia sort()  sorts the list in numerical and lexicographical order and returns None. Lists can also be reversed when sorted using the reverse=True flag in the sort() method. a.sort() # a = [1, 2, 3, 4, 5, 6, 7, 8] # Sorts the list in numerical order a.sort(reverse=True) # a = [8, 7, 6, 5, 4, 3, 2, 1] You can iterate over the list elements like below: for element in my_list: print (element) Replication multiplying an existing list by an integer will produce a larger list consisting of that many copies of the original. This can be useful for example for list initialization b = [&quot;blah&quot;] * 3 # b = [&quot;blah&quot;, &quot;blah&quot;, &quot;blah&quot;] b = [1, 3, 5] * 5 # [1, 3, 5, 1, 3, 5, 1, 3, 5, 1, 3, 5, 1, 3, 5] Element deletion it is possible to delete multiple elements in the list using the del keyword and slice notation: a = list(range(10)) del a[::2] # a = [1, 3, 5, 7, 9] del a[-1] # a = [1, 3, 5, 7] del a[:] # a = [] Copying The default assignment = assigns a reference of the original list to the new name. That is, the original name and new name are both pointing to the same list object. Changes made through any of them will be reflected in another. This is often not what you intended. a= [1, 2, 3, 4, 5] b = a a.append(6) # b: [1, 2, 3, 4, 5, 6] If you want to create a copy of the list you have below options. You can slice it: new_list = old_list[:] or You can use the built in list() function: new_list = list(old_list) copy()  Returns a shallow copy of the list a= [1, 2, 3, 4, 5] aa = a.copy() # aa = [1, 2, 3, 4, 5] Checking if list is empty The emptiness of a list is associated to the boolean False, so you dont have to check len(lst) == 0, but just lst or not lst. lst = [] if not lst: print(&quot;list is empty&quot;) # Output: list is empty list is empty Checking whether an item is in a list Python makes it very simple to check whether an item is in a list. Simply use the in operator. lst = [&#39;test&#39;, &#39;tweet&#39;, &#39;troop&#39;, &#39;treat&#39;] &#39;test&#39; in lst # Out: True True &#39;toast&#39; in lst # Out: False False zip returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables: alist = [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;] blist = [&#39;b1&#39;, &#39;b2&#39;, &#39;b3&#39;] for a, b in zip(alist, blist): print(a, b) a1 b1 a2 b2 a3 b3 If the lists have different lengths then the result will include only as many elements as the shortest one: alist = [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;] blist = [&#39;b1&#39;, &#39;b2&#39;, &#39;b3&#39;, &#39;b4&#39;] for a, b in zip(alist, blist): print(a, b) a1 b1 a2 b2 a3 b3 Length of a list Use len() to get the one-dimensional length of a list. len() also works on strings, dictionaries, and other data structures similar to lists. Remove duplicate values in list Removing duplicate values in a list can be done by converting the list to a set (that is an unordered collection of distinct objects). If a list data structure is needed, then the set can be converted back to a list using the function list(). Note that by converting a list to a set the original ordering is lost. 2.3 List comprehensions List comprehensions in Python are concise, syntactic constructs. They can be utilized to generate list from other lists by applying functions to each element in the list. The following section explains and demonstrates the use of these expressions A list comprehension creates a new list by applying an expression to each element of an iterable. The most basic form is: [ &lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; ] Theres also an optional if condition: for example To create a list of squared integers: squares = [x * x for x in (1, 2, 3, 4)] # create a list of characters in apple, replacing non vowels with &#39;*&#39; # When using if/else together use them before the loop [x if x in &#39;aeiou&#39; else &#39;*&#39; for x in &#39;apple&#39;] #[&#39;a&#39;, &#39;*&#39;, &#39;*&#39;, &#39;*&#39;, &#39;e&#39;] Double Iteration Order of double iteration [... for x in ... for y in ...] is either natural or counter-intuitive. The rule of thumb is to follow an equivalent for loop: In-place Mutation and Other Side Effects Before using list comprehension, understand the difference between functions called for their side effects (mutating, or in-place functions) which usually return None, and functions that return an interesting value. Many functions (especially pure functions) simply take an object and return some object. An in-place function modifies the existing object, which is called a side effect. Other examples include input and output operations such as printing. list.sort() sorts a list in-place (meaning that it modifies the original list) and returns the value None. Therefore, it wont work as expected in a list comprehension: [x.sort() for x in [[2, 1], [4, 3], [0, 1]]] # [None, None, None] sorted() returns a sorted list rather than sorting in-place. [sorted(x) for x in [[2, 1], [4, 3], [0, 1]]] # [[1, 2], [3, 4], [0, 1]] Conditional List Comprehensions [&lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; if &lt;condition&gt;] For each &lt;element&gt; in &lt;iterable&gt;; if &lt;condition&gt; evaluates to True, add &lt;expression&gt; (usually a function of &lt;element&gt;) to the returned list. For example, this can be used to extract only even numbers from a sequence of integers: [x for x in range(10) if x % 2 == 0] # Out: [0, 2, 4, 6, 8] 2.4 Tuples A tuple is similar to a list except that it is fixed-length and immutable. So the values in the tuple cannot be changed nor the values be added to or removed from the tuple. Tuples are commonly used for small collections of values that will not need to change, such as an IP address and port. Tuples are represented with parentheses instead of square brackets. The same indexing rules for lists also apply to tuples. Tuples can also be nested and the values can be any valid Python. A tuple with only one member must be defined (note the comma) this way: one_member_tuple = (&#39;Only member&#39;,) One of the main differences between lists and tuples in Python is that tuples are immutable, that is, one cannot add or modify items once the tuple is initialized. tuples dont have .append and .extend methods as list does. You can use the += operator to append to a tuple - this works by creating a new tuple with the new element you appended and assign it to its current variable; the old tuple is not changed, but replaced! Note that a one-value tuple is also a tuple. To tell Python that a variable is a tuple and not a single value you can use. The symbol _ can be used as a disposable variable name if one only needs some elements of a tuple, acting as a placeholder: a = 1, 2, 3, 4 _, x, y, _ = a # x == 2 # y == 3 2.5 Dictionaries A dictionary in Python is a collection of key-value pairs. The dictionary is surrounded by curly braces. Each pair is separated by a comma and the key and value are separated by a colon. Here is an example: capitals = { &#39;India&#39;: &#39;Delhi&#39;, &#39;Pak&#39;: &#39;Islamabad&#39;, &#39;Nepal&#39;: &#39;Katmandu&#39;, } # To get a value, refer to it by its key: India_capital = capitals[&#39;India&#39;] You can also get all of the keys in a dictionary and then iterate over them: for k in capitals.keys(): print(&#39;{} is the capital of {}&#39;.format(capitals[k], k)) 2.6 Set A set is a collection of elements with no repeats and without insertion order but sorted order. They are used in situations where it is only important that some things are grouped together, and not what order they were included. For large groups of data, it is much faster to check whether or not an element is in a set than it is to do the same for a list. Defining a set is very similar to defining a dictionary: first_names = {&#39;Adam&#39;, &#39;Beth&#39;, &#39;Charlie&#39;} # Or you can build a set using an existing list my_list = [1,2,3] my_set = set(my_list) # iteration on set for name in first_names: print(name) # check if element is there in set if name in first_names: print(name) "],["simple-mathematics.html", "3 Simple Mathematics 3.1 Comparisons 3.2 Conditionals 3.3 if, elif, and else 3.4 Boolean Operators 3.5 Loops 3.6 For loops 3.7 While Loop", " 3 Simple Mathematics Addition a, b = 1, 2 # Using the &quot;+&quot; operator: a + b # = 3 if we add different data types these are the possible combinations (builtin types): - int and int (gives an int) - int and float (gives a float) - int and complex (gives a complex) - float and float (gives a float) - float and complex (gives a complex) - complex and complex (gives a complex) Note: the + operator is also used for concatenating strings, lists and tuples: &quot;first string &quot; + &quot;second string&quot; # = &#39;first string second string&#39; [1, 2, 3] + [4, 5, 6] # = [1, 2, 3, 4, 5, 6] Subtraction a, b = 1, 2 # Using the &quot;-&quot; operator: b - a # = 1 if we subtract different data types these are the possible combinations (builtin types): - int and int (gives an int) - int and float (gives a float) - int and complex (gives a complex) - float and float (gives a float) - float and complex (gives a complex) - complex and complex (gives a complex) Multiplication a, b = 2, 3 var = a * b # = 6 Division a, b = 2, 3 var = b / a # = 1.5 int and int (gives an int in Python 2 and a float in Python 3) int and float (gives a float) int and complex (gives a complex) float and float (gives a float) float and complex (gives a complex) complex and complex (gives a complex) Exponentiation a, b = 2, 3 a ** b # = 8 Modulus Like in many other languages, Python uses the % operator for calculating modulus. 3 % 4 # 3 10 % 2 # 0 6 % 4 # 2 3.1 Comparisons Comparison by is vs == a == b compares the value of a and b. it returns true if values of a is equal to b. a is b will compare the identities of a and b. Basically, is can be thought of as shorthand for id(a) == id(b). lets understand this with an example. a = &#39;Python is fun!&#39; b = &#39;Python is fun!&#39; a == b # returns True a is b # returns False a = [1, 2, 3, 4, 5] b = a # b references a a == b # True a is b # True b = a[:] # b now references a copy of a a == b # True a is b # False Greater than or less than x &gt; y x &lt; y These operators compare two types of values, theyre the less than and greater than operators. For numbers this simply compares the numerical values to see which is larger. For strings they will compare lexicographically, which is similar to alphabetical order but not quite the same 12 &gt; 4 # True 12 &lt; 4 # False 1 &lt; 4 # True &quot;alpha&quot; &lt; &quot;beta&quot; # True &quot;gamma&quot; &gt; &quot;beta&quot; # True &quot;gamma&quot; &lt; &quot;OMEGA&quot; # False Not equal to x != y This returns True if x and y are not equal and otherwise returns False. 12 != 1 # True 12 != &#39;12&#39; # True &#39;12&#39; != &#39;12&#39; # False 3.2 Conditionals Conditional expressions, involving keywords such as if, elif, and else, provide Python programs with the ability to perform different actions depending on a boolean condition: True or False. This section covers the use of Python conditionals, boolean logic, and ternary statements. 3.3 if, elif, and else In Python you can define a series of conditionals using if for the first one, elif for the rest, up until the final (optional) else for anything not caught by the other conditionals. number = 5 if number &gt; 2: print(&quot;Number is bigger than 2.&quot;) elif number &lt; 2: # Optional clause (you can have multiple elifs) print(&quot;Number is smaller than 2.&quot;) else: # Optional clause (you can only have one else) print(&quot;Number is 2.&quot;) Number is bigger than 2. Using else if instead of elif will trigger a syntax error and is not allowed. 3.4 Boolean Operators and check the and condition. return True if both the conditions are true. x = True y = True z = x and y # z = True x = True y = False z = x and y # z = False x = False y = True z = x and y # z = False x = False y = False z = x and y # z = False or Return True if any of the conditions is true. x = True y = True z = x or y # z = True x = True y = False z = x or y # z = True x = False y = True z = x or y # z = True x = False y = False z = x or y # z = False not It returns the opposite of the statement. x = True y = not x # y = False x = False y = not x # y = True Testing for multiple conditions A common mistake when checking for multiple conditions is to apply the logic incorrectly. Each variable needs to be compared separately. a=1 b=6 if a &gt; 2 and b &gt; 2: print(&#39;yes&#39;) else: print(&#39;no&#39;) no if a == 3 or a == 4 or a == 6: # checking or condition print(&#39;yes&#39;) else: print(&#39;no&#39;) no 3.5 Loops 3.6 For loops for loops iterate over a collection of items, such as list or dict, and run a block of code with each element from the collection. for i in [0, 1, 2, 3, 4]: print(i) The above for loop iterates over a list of numbers and print each item. range is a function that returns a series of numbers under an iterable form, thus it can be used in for loops: for i in range(5): print(i) # Returns 0 1 2 3 4 Note that 5 is not printed as the range here is the first five numbers counting from 0. In range function we can also give starting and ending number. for example for x in range(1, 6): print(x) # Returns 1 2 3 4 5 Iterating over lists To iterate through a list you can use for: for x in [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]: print(x) # This will print out the elements of the list: one two three four If you want to loop though elements of a list and have an index for the elements as well, you can use Pythons enumerate function: for index, item in enumerate([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]): print(index, &#39;:&#39;, item) 0 : one 1 : two 2 : three 3 : four enumerate will generate tuples, which are unpacked into index (an integer) and item (the actual value from the list). The above loop will print. The Pass Statement pass is a null statement for when a statement is required by Python syntax (such as within the body of a for or while loop), but no action is required or desired by the programmer. for x in range(10): pass #we don&#39;t want to do anything, or are not ready to do anything here, so we&#39;ll pass In this example, nothing will happen. The for loop will complete without error, but no commands or code will be executed. pass allows us to run our code successfully without having all commands and action fully implemented Iterating over dictionaries To iterate through keys of a dictionary, you can use: d = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3} for key in d: print(key) a b c This is equivalent to: for key in d.keys(): print(key) To iterate through its values, use: for value in d.values(): print(value) 1 2 3 To iterate through its keys and values, use: for key, value in d.items(): print(key, &quot;::&quot;, value) a :: 1 b :: 2 c :: 3 Looping and Unpacking If you want to loop over a list of tuples for example: collection = [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;), (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;)] # we can unbox the items like for i1, i2, i3 in collection: print(f&#39;{i1} : {i2} : {i3}&#39;) a : b : c x : y : z 1 : 2 : 3 Iterating different portion of a list with different step size Suppose you have a long list of elements and you are only interested in every other element of the list. Perhaps you only want to examine the first or last elements, or a specific range of entries in your list. Python has strong indexing built-in capabilities. Here are some examples of how to achieve these scenarios lst = [&#39;alpha&#39;, &#39;bravo&#39;, &#39;charlie&#39;, &#39;delta&#39;, &#39;echo&#39;] for s in lst: print (s[:1]) # print the first letter a b c d e for idx, s in enumerate(lst): print(&quot;%s has an index of %d&quot; % (s, idx)) alpha has an index of 0 bravo has an index of 1 charlie has an index of 2 delta has an index of 3 echo has an index of 4 for i in range(2,4): print(&quot;lst at %d contains %s&quot; % (i, lst[i])) lst at 2 contains charlie lst at 3 contains delta for s in lst[1::2]: print(s) bravo delta 3.7 While Loop A while loop will cause the loop statements to be executed until the loop condition is false. The following code will execute the loop statements a total of 4 times. i = 0 while i &lt; 4: #loop statements i = i + 1 3.7.1 break statement When a break statement executes inside a loop, control flow breaks out of the loop immediately: i = 0 while i &lt; 7: print(i) if i == 4: print(&quot;Breaking from loop&quot;) break i += 1 The loop conditional will not be evaluated after the break statement is executed. Note that break statements are only allowed inside loops. A break statement inside a function cannot be used to terminate loops that called that function. break statements can also be used inside for loops. for i in (0, 1, 2, 3, 4): print(i) if i == 2: break 0 1 2 3.7.2 continue statement A continue statement will skip to the next iteration of the loop bypassing the rest of the current block but continuing the loop. As with break, continue can only appear inside loops. for i in (0, 1, 2, 3, 4, 5): if i == 2 or i == 4: continue print(i) 0 1 3 5 Note that 2 and 4 arent printed, this is because continue goes to the next iteration instead of continuing on to print(i) when i == 2 or i == 4. Nested Loops break and continue only operate on a single level of loop. The following example will only break out of the inner for loop, not the outer while loop. while True: for i in range(1,5): if i == 2: break # Will only break out of the inner loop! Python doesnt have the ability to break out of multiple levels of loop at once. if this behavior is desired, refactoring one or more loops into a function and replacing break with return may be the way to go. "],["built-in-modules-and-functions.html", "4 Built in Modules and Functions 4.1 Creating a module 4.2 Installing external modules using pip", " 4 Built in Modules and Functions A module is a file containing Python definitions and statements. Function is a piece of code which execute some logic. To check the built in function in python we can use dir(). dir(__builtins__) # returns list of all the builtin modules and function available in python import math dir(math) # return all the function available in math package To know the functionality of any function, we can use built in function help(). 4.1 Creating a module A module is an importable file containing definitions and statements. A module can be created by creating a .py file. # create a file and name it hello.py def say_hello(): print(&quot;Hello!&quot;) Functions in a module can be used by importing the module. For modules that you have made, they will need to be in the same directory as the file that you are importing them into. Modules can be imported by other modules. # in another file greet.py import hello hello.say_hello() Specific functions of a module can be imported # greet.py from hello import say_hello say_hello() Modules can be aliased. we can give an alias to the module if required. as keyword is used to alias a module. # greet.py import hello as ai ai.say_hello() 4.2 Installing external modules using pip pip is your friend when you need to install any package from the plethora of choices available at the python package index. pip is already installed if youre using Python 2 &gt;= 2.7.9 or Python 3 &gt;= 3.4. Finding a package $ pip search &lt;query&gt; # Searches for packages whose name or summary contains &lt;query&gt; Installing a package is as simple as typing in a terminal / command-prompt. $ pip install [package_name] # latest version of the package $ pip install [package_name]==x.x.x # specific version of the package $ pip install &#39;[package_name]&gt;=x.x.x&#39; # minimum version of the package # where x.x.x is the version number of the package you want to install Upgrading installed packages To get an overview of which of your installed packages have become outdated, run $ pip list --outdated # To upgrade a specific package use $ pip install [package_name] --upgrade "],["functions.html", "5 Functions 5.1 Lambda function", " 5 Functions Functions in Python provide organized, reusable and modular code to perform a set of specific actions. Functions simplify the coding process, prevent redundant logic, and make the code easier to follow. This section describes the declaration and utilization of functions in Python. Python has many built-in functions like print(), input(), len(). Besides built-ins you can also create your own functions to do more specific jobsthese are called user-defined functions. Defining and calling simple functions Using the def statement is the most common way to define a function in python. Heres an example of a simple function definition which purpose is to print Hello each time its called: def greet(): print(&quot;Hello&quot;) #Now lets call the defined greet() function: greet() Hello Thats another example of a function definition which takes one single argument and displays the passed in value each time the function is called: def greet_two(greeting): print(greeting) #Now lets call the greet_two() function. Note that we have to give an argument to this function greet_two(&quot;Howdy&quot;) Howdy Also you can give a default value to that function argument: def greet_three(greeting=&quot;Howdy&quot;): print(greeting) #Now you can also call this function without giving argument, in that case it will use default value. greet_three() Howdy greet_three(&quot;Hello&quot;) Hello Youll notice that unlike many other languages, you do not need to explicitly declare a return type of the function. Python functions can return values of any type via the return keyword. One function can return any number of different types. def many_types(x): if x &lt; 0: return &quot;Hello!&quot; else: return 0 print(many_types(1)) 0 print(many_types(-1)) Hello! As long as this is handled correctly by the caller, this is perfectly valid Python code. Arbitrary number of positional arguments Defining a function capable of taking an arbitrary number of arguments can be done by prefixing one of the arguments with a * def func(*args): # args will be a tuple containing all values that are passed in for i in args: print(i) func(1, 2, 3) # Calling it with 3 arguments 1 2 3 You cant provide a default for args, for example func(*args=[1, 2, 3]) will raise a syntax error Arbitrary number of keyword arguments You can take an arbitrary number of arguments with a name by defining an argument in the definition with two * in front of it: def func(**kwargs): # kwargs will be a dictionary containing the names as keys and the values as values for name, value in kwargs.items(): print(name, value) func(value1=1, value2=2, value3=3) # Calling it with 3 arguments value1 1 value2 2 value3 3 func() # Calling it without arguments. no output my_dict = {&#39;foo&#39;: 1, &#39;bar&#39;: 2} func(**my_dict) # Calling it with a dictionary foo 1 bar 2 You cant provide these without names, for example func(1, 2, 3) will raise a TypeError. kwargs is a plain native python dictionary Returning values from functions A function with no return statement implicitly returns None. Similarly a function with a return statement, but no return value or variable returns None. if return is encountered in the function the function will be exited immediately and subsequent operations will not be evaluated: Function unpacking Functions allow you to specify these types of parameters: positional, named, variable positional, Keyword args (kwargs). Here is a clear and concise use of each type. def unpacking(a, b, c=45, d=60, *args, **kwargs): print(a, b, c, d, args, kwargs) unpacking(1,2) 1 2 45 60 () {} unpacking(1,2, 3, 4) 1 2 3 4 () {} unpacking(1,2, c=3, d=4) 1 2 3 4 () {} unpacking(1,2, d=4, c=3) 1 2 3 4 () {} 5.1 Lambda function The lambda keyword creates an inline function that contains a single expression. The value of this expression is what the function returns when invoked. A lambda function can be written as follows: greet_me = lambda: \"Hello\" Once assigned to a variable, it can be used just like a regular function: print(greet_me()) lambdas can take arguments, too: They can also take arbitrary number of arguments / keyword arguments, like normal functions. greeting = lambda x, *args, **kwargs: print(x, args, kwargs) greeting(&#39;hello&#39;, &#39;world&#39;, world=&#39;world&#39;) hello (&#39;world&#39;,) {&#39;world&#39;: &#39;world&#39;} lambdas are commonly used for short functions that are convenient to define at the point where they are called (typically with sorted, filter and map). "],["introduction-to-numpy.html", "6 Introduction to Numpy 6.1 Why is NumPy Fast?", " 6 Introduction to Numpy What is NumPy? This introduction is taken from official site here. NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more. At the core of the NumPy package, is the ndarray object. This encapsulates n-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. There are several important differences between NumPy arrays and the standard Python sequences. NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an ndarray will create a new array and delete the original. The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory. The exception: one can have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements. NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Pythons built-in sequences. A growing plethora of scientific and mathematical Python-based packages are using NumPy arrays; though these typically support Python-sequence input, they convert such input to NumPy arrays prior to processing, and they often output NumPy arrays. In other words, in order to efficiently use much (perhaps even most) of todays scientific/mathematical Python-based software, just knowing how to use Pythons built-in sequence types is insufficient - one also needs to know how to use NumPy arrays. The points about sequence size and speed are particularly important in scientific computing. As a simple example, consider the case of multiplying each element in a 1-D sequence with the corresponding element in another sequence of the same length. For example if the data are stored in two Python lists, a and b, and we want to multiply element of both list we can do it in python like: c = [] for i in range(len(a)): c.append(a[i]*b[i]) This produces the correct answer, but if a and b each contain millions of numbers, we will pay the price for the inefficiencies of looping in Python. We could accomplish the same task much more quickly in C by writing for (i = 0; i &lt; rows; i++): { [i] = a[i]*b[i]; } we know code is C are faster then that are in python. NumPy gives us the best of both worlds: element-by-element operations are the default mode when an ndarray is involved, but the element-by-element operation is speedily executed by pre-compiled C code. In NumPy the above multiplication can be achieved by c = a*b The examples above is executed, at near-C speeds, but with the code simplicity we expect from something based on Python. Indeed, the NumPy idiom is even simpler! This last example illustrates two of NumPys features which are the basis of much of its power: vectorization and broadcasting. 6.1 Why is NumPy Fast? Vectorization describes the absence of any explicit looping, indexing, etc., in the code - these things are taking place, of course, just behind the scenes in optimized, pre-compiled C code. Vectorized code has many advantages, among which are: vectorized code is more concise and easier to read fewer lines of code generally means fewer bugs the code more closely resembles standard mathematical notation (making it easier, typically, to correctly code mathematical constructs) vectorization results in more Pythonic code. Without vectorization, our code would be littered with inefficient and difficult to read for loops. the code is edited today "],["basic-reservoir-engineering.html", "Basic Reservoir Engineering", " Basic Reservoir Engineering "],["fundamental-properties-of-fluid.html", "7 Fundamental Properties of Fluid 7.1 Review of Gas Properties", " 7 Fundamental Properties of Fluid 7.1 Review of Gas Properties 7.1.1 Real Gas law There are no gas that behaves as Ideal gas. The volume of Real gas is more that Ideal gas. The number that measure the amount of gas deviates from perfect gas is actually a ratio. this ratio is called as compressibility factor or gas deviation factor. this is a dimensionless quantity. If the gas deviation factor is not measured it can be estimated from the specific gravity of the gas. Sutton developed a correlation that estimates \\[\\begin{equation} \\tag{7.1} Ppc = 756.8 -131*Sg - 3.6 * Sg^2 \\\\ Tpc = 169.2 -349.5*Sg - 74 * Sg^2 \\end{equation}\\] We will write a small code to plot this correlation. import numpy as np import matplotlib.pyplot as plt Sg = np.arange(0.57,1.68,0.05) Ppc = [756.8 -131*sg - 3.6 * sg*sg for sg in Sg] Tpc = [169.2 + 349.5*sg - 74 * sg*sg for sg in Sg] plt.plot(Sg, Ppc, &#39;r-&#39;) [&lt;matplotlib.lines.Line2D object at 0x000000002C508760&gt;] plt.plot(Sg, Tpc, &#39;b-&#39;) [&lt;matplotlib.lines.Line2D object at 0x000000002CBB8CA0&gt;] plt.grid() plt.ylabel(&#39;Pseudo-critical Pressure and Temperature (psia and R)&#39;) Text(0, 0.5, &#39;Pseudo-critical Pressure and Temperature (psia and R)&#39;) plt.xlabel(&#39;Gas specific gravity&#39;) Text(0.5, 0, &#39;Gas specific gravity&#39;) plt.show() Wiechert-Aziz have developed a correlation to account for gases that contain CO2 and H2S \\[\\begin{equation} e = 120(A^{0.9} - A^{1.6}) + 15(B^{0.5} - B^4) \\end{equation}\\] A = sum of mole fraction of H2S and CO2 B = sum of mole fraction of H2S with this correation the modified equation becomes: \\[\\begin{equation} \\tag{7.2} T&#39;_{pc} = T_{pc} -e \\\\ P&#39;_{pc} = \\frac{P_{pc}T&#39;_{pc}}{(T_{pc}- B(1-B)e)} \\end{equation}\\] Lets assume H2S mole fraction of 0.05 and CO2 mole fraction of 0.1 and compare the plots # same code as above x_h2s=0.05 x_co2 =0.1 e = (120 * (((x_h2s + x_co2)**0.9) - ((x_h2s + x_co2)**1.6))) + (15 * (x_h2s**0.5 - x_h2s**4)) T_pc_corr = [T - e for T in Tpc] P_pc_corr = [(Ppc[i] * T_pc_corr[i]) / (Tpc[i] - x_h2s * e * (1-x_h2s)) for i in range(len(Tpc))] fig, ax = plt.subplots() ax.plot(Sg, Ppc, &#39;r-&#39;) [&lt;matplotlib.lines.Line2D object at 0x000000002D739D90&gt;] ax.plot(Sg, Tpc, &#39;b-&#39;) [&lt;matplotlib.lines.Line2D object at 0x000000002D739E20&gt;] ax.plot(Sg, P_pc_corr, &#39;r--&#39;) [&lt;matplotlib.lines.Line2D object at 0x000000002D74A310&gt;] ax.plot(Sg, T_pc_corr, &#39;b--&#39;) [&lt;matplotlib.lines.Line2D object at 0x000000002D74A6D0&gt;] ax.grid() plt.ylabel(&#39;Pseudo-critical Pressure and Temperature (psia and R)&#39;) Text(0, 0.5, &#39;Pseudo-critical Pressure and Temperature (psia and R)&#39;) plt.xlabel(&#39;Gas specific gravity&#39;) Text(0.5, 0, &#39;Gas specific gravity&#39;) plt.show() 7.1.2 Gas z Factor Dranchuk and Aboukassem equation of state The form of equation is as follow: \\[\\begin{equation} \\begin{split} z = 1 + c_{1}(T_{pr}) p_{r} + c_{2}(T_{pr})p_{r}^2 - c_{3}(T_{pr})p_{r}^5 + c_{4}(T_{pr}p_{r}) \\\\ where : \\\\ p_{r} = 0.27 P_{pr}/(zT_{pr}) \\\\ c_{1}(T_{pr}) = A_{1} + A_{2}/T_{pr} + A_{3}/T_{pr}^3 + A_{4}/T_{pr}^4 + A_{5}/T_{pr}^5\\\\ c_{2}(T_{pr}) = A_{6} + A_{7}/T_{pr} + A_{8}/T_{pr}^2 \\\\ c_{3}(T_{pr}) = A_{9}(A_{7}/T_{pr} + A_{8}/T_{pr}^2) \\\\ c_{4}(T_{pr}p_{r}) = A_{10}( 1 + A_{11}p_{r}^2)(p_{r}^2/T_{pr}^3) exp(-A_{11}p_{r}^2) \\\\ \\end{split} \\tag{7.3} \\end{equation}\\] where \\[\\begin{equation} A_{1} = 0.3265; A_{2} = -1.0700; A_{3} = -0.5339; A_{4} = 0.01569; A_{5} = -0.05165; A_{6} = 0.5475 \\\\ A_{7} = -0.7361; A_{8} = 0.1844; A_{9} = 0.1056; A_{10} = 0.6134; A_{11} = 0.7210 \\end{equation}\\] The above equation has z-factor on both side of the equation. To solve such equation a trial and error solution is required. However, in Python we can solve this equation using fsolve function of scipy library, which is a non-linear solver. import numpy as np from scipy.optimize import fsolve # non-linear solver def getZ_dranchuk(T_pr, P_pr): a1 = 0.3265; a2 = -1.0700; a3 = -0.5339; a4 = 0.01569; a5 = -0.05165; a6 = 0.5475 a7 = -0.7361; a8 = 0.1844; a9 = 0.1056; a10 = 0.6134; a11 = 0.7210 def func(y): rho_pr, z = y c1 = a1 + (a2/T_pr) + (a3/(T_pr**3))+ (a4/(T_pr**4))+ (a5/(T_pr**5)) c2 = a6 + (a7/T_pr) + (a8/(T_pr**2)) c3 = a9*((a7/T_pr) + (a8/(T_pr**2))) c4 = (a10)*(1+(a11*(rho_pr**2)))*((rho_pr**2)/(T_pr**3))*(np.exp(-a11*(rho_pr**2))) f1 = z + (c3*(rho_pr**5)) - (c2*(rho_pr**2)) - (c1*(rho_pr**1)) - c4 - 1 f2 = rho_pr - ((0.27 * P_pr) / (z * T_pr)) return[f1, f2] def dranchuk(): solve = fsolve(func, [1, 1]) # initial guess return(solve[0], solve[1]) return dranchuk()[1] # lets Assume T_pr = 1.8 P_pr = 4.87 print(f&#39;Gas Deviation factor Z : = {getZ_dranchuk(T_pr, P_pr)}&#39;) Gas Deviation factor Z : = 0.9110107290176761 7.1.3 Gas Density Density of a real gas can be calculated using the formula given below: \\[\\begin{equation} \\tag{7.4} \\rho_g = \\frac{1}{v} = \\frac{pM_a}{zRT} \\end{equation}\\] Using the data in below assuming real gas behavior, lets calculate the density of the gas phase under initial reservoir conditions. # Component [CO2, N2, C1, C2, C3, i-C4, n-c4] gasComposition = [0.02, 0.01, 0.85, 0.04, 0.03, 0.03, 0.02] MW = [44.01, 28.01, 16.04, 30.1, 44.1, 58.1, 58.1] Tc = [547.91, 227.49 , 343.33, 549.92, 666.06, 734.46, 765.62] #Rankine Pc = [1071, 493.1, 666.4, 706.5, 616.4, 527.9, 550.6] Ma = sum([y*M for y, M in zip(gasComposition, MW)]) Tpc = sum([y*T for y, T in zip(gasComposition, Tc)]) Ppc = sum([y*P for y, P in zip(gasComposition, Pc)]) P = 3000 # Reservoir Pressure in psi T = 640 # Reservoir Temperature in R R = 10.73 # T_pr = T/Tpc P_pr = P/Ppc Z = getZ_dranchuk(T_pr, P_pr) density = P*Ma/(Z*R*T) # Results print(&#39;-&#39;*50) -------------------------------------------------- print(f&#39;Apparent molecular weight : = {round(Ma, 2)}&#39;) Apparent molecular weight : = 20.23 print(f&#39;Pseudo-critical pressure : = {round(Ppc, 2)} psi&#39;) Pseudo-critical pressure : = 666.39 psi print(f&#39;Pseudo-critical temperature : = {round(Tpc, 2)} R&#39;) Pseudo-critical temperature : = 384.39 R print(f&#39;Pseudo-reduced pressure : = {round(P_pr, 2)}&#39;) Pseudo-reduced pressure : = 4.5 print(f&#39;Pseudo-reduced temperature : = {round(T_pr, 2)}&#39;) Pseudo-reduced temperature : = 1.66 print(f&#39;Gas Deviation factor : = {round(Z, 2)}&#39;) Gas Deviation factor : = 0.86 print(f&#39;Gas Density : = {round(density, 2)} lb/ft3&#39;) Gas Density : = 10.28 lb/ft3 7.1.4 Isothermal Gas Compressibility Isothermal compressibility is defined as change in volume with pressure for gas under isothermal condition. \\[\\begin{equation} \\tag{7.5} V = znR&#39;T/P \\\\ or \\\\ V = constant * z/P \\end{equation}\\] Mattar, Brar, and Aziz developed an analytical expression for calculating pseudo-reduced compressibility. By taking the derivative of equation of state developed by Dranchuck and Abou-Kassem developed the following equation. # code for Isothermal Gas Compressibility using Dranchuck and Abou-Kassem equation import numpy as np a1 = 0.3265; a2 = -1.0700; a3 = -0.5339; a4 = 0.01569; a5 = -0.05165; a6 = 0.5475 a7 = -0.7361; a8 = 0.1844; a9 = 0.1056; a10 = 0.6134; a11 = 0.7210 def mattar(T_pr, P_pr, rho_pr, z, P_pc_corr): do = ((a1 + (a2/T_pr) + (a3/T_pr**3) +(a4/T_pr**4) + (a5/T_pr**5)) * rho_pr) + \\ (2 * ((a6 + (a7/T_pr) + (a8/T_pr**2))) * rho_pr**2) - \\ (5 * a9 * (((a7/T_pr) + (a8/T_pr**2))) * rho_pr**4) + (1 + (a11 * rho_pr**2) - (a11 * rho_pr**2)**2) \\ * ((2 * a10 * rho_pr / T_pr**3)*np.exp(-a11 * rho_pr**2)) c_pr_analytical = (1 / P_pr) - ((0.27 / (z**2 * T_pr)) * (do / (1 + ((rho_pr / z) * do)))) cgas_analytical = c_pr_analytical / P_pc_corr return(cgas_analytical) print(mattar(1.44, 7.08, 0.80, 0.91, 636)) 0.00021157987661567598 7.1.5 Gas formation volume factor Gas formation volume factor relates the volume of gas in the reservoir to the volume of gas on the surface at standard conditions so, Bg can be written as Bg = 0.02829 zT/p in ft3/scf = 0.00504 zT/P bbl/scf. z= 0.91 P = 3250 # psia T = 213 # F Bg = 0.02829*z*(T+460)/P print (f&#39;Gas formation volume Factor : {Bg}&#39;) Gas formation volume Factor : 0.005330967600000001 "],["properties-of-oil.html", "8 Properties of Oil", " 8 Properties of Oil Basic oil properties from compositions The properties of mixture of oil can be calculated from molar fraction of individual components. for example # lets take four component names = [&#39;C3&#39;, &#39;nC4&#39;, &#39;nC5&#39;, &#39;nC6&#39;] # name of component frac = [0.05, 0.15, 0.2, 0.6] # volume fraction rho = [507.2, 583.9, 629.5, 659.8] # Mass density MW = [44.09, 58.12, 72.15, 86.17] # Molecular weight ncomp = len(names) m = [rho[i]*frac[i] for i in range(ncomp)] # Mass of each component n = [m[i]/MW[i] for i in range (ncomp)] # MOles of each component Mass = sum(m) moles = sum(n) w = [m[i]/ Mass for i in range(ncomp)] # Weight Fraction mol_frac = [n[i]/ moles for i in range(ncomp)] # Mole fraction Total_MW = Mass / moles # Molecular weight of total composition Sg = Mass / 1000 # specific gravity API = 141.5 / Sg - 131.5 # Oil API print(&#39;Mixture MW:&#39;, round(Total_MW,3), &#39;lbm/lbm mol&#39;) Mixture MW: 75.371 lbm/lbm mol print(&#39;Mixture Density:&#39;, round(Mass, 3), &#39;kg/m3&#39;) Mixture Density: 634.725 kg/m3 print(&#39;Mixture SG::&#39;, round(Sg ,3)) Mixture SG:: 0.635 print(&#39;degrees API:&#39;, round(API,3), &#39;API&#39;) degrees API: 91.431 API "],["rock-properties.html", "9 Rock Properties 9.1 Surface and Interfacial Tension 9.2 Capillary Pressure 9.3 Leverett J-Function 9.4 Permeability 9.5 Reservoir Heterogeneity", " 9 Rock Properties 9.1 Surface and Interfacial Tension In dealing with multiphase systems, it is necessary to consider the effect of the forces at the interface when two immiscible fluids are in contact. When these two fluids are liquid and gas, the term surface tension is used to describe the forces acting on the interface. When the interface is between two liquids, the acting forces are called interfacial tension. The surface or interfacial tension has the units of force per unit of length, e.g., dynes/cm, Assuming the radius of the capillary tube is r, the total upward force Fup, which holds the liquid up, is equal to the force per unit length of surface times the total length of surface, or \\[\\begin{equation} \\tag{9.1} F_{up} = 2\\pi r \\sigma_{gw} (cos\\theta) \\end{equation}\\] where sigma_gw = surface tension between air (gas) and water (oil). dynes/cm theta = contact angle r = radius, cm The upward force is counteracted by the weight of the water, which is equivalent to a downward force of mass times acceleration, or \\[\\begin{equation} \\tag{9.2} F_{down} = \\pi r^2 h (\\rho_{w} -\\rho_{air})g \\end{equation}\\] where h = height to which the liquid is held, cm g = acceleration due to gravity, cm/sec2 Rho_w = density of water, gm/cm3 Rho_air = density of gas, gm/cm3 Equating (9.1) and (9.2) solving for the surface tension when applying for two liquids, i.e., water and oil this equation becomes: \\[\\begin{equation} \\tag{9.3} \\rho_{ow} = \\frac{rhg(\\rho_{w} -\\rho_{o})}{2cos\\theta} \\end{equation}\\] 9.2 Capillary Pressure The capillary forces in a petroleum reservoir are the result of the combined effect of the surface and interfacial tensions of the rock and fluids, the pore size and geometry, and the wetting characteristics of the system. Any curved surface between two immiscible fluids has the tendency to contract into the smallest possible area per unit volume. This is true whether the fluids are oil and water, water and gas. The displacement of one fluid by another in the pores of a porous medium is either aided or opposed by the surface forces of capillary pressure. As a consequence, in order to maintain a porous medium partially saturated with nonwetting fluid and while the medium is also exposed to wetting fluid, it is necessary to maintain the pressure of the nonwetting fluid at a value greater than that in the wetting fluid Capillary pressure = (pressure of the nonwetting phase) - (pressure of the wetting phase) There are three types of capillary pressure: - Water-oil capillary pressure (denoted as Pcwo) - Gas-oil capillary pressure (denoted as Pcgo) - Gas-water capillary pressure (denoted as Pcgw) In practical units, Capillary pressure is written as \\[\\begin{equation} \\tag{9.4} P_c = \\frac{h}{144} \\Delta \\rho \\end{equation}\\] where Pc = capillary pressure, psi h = capillary rise, ft Delta_rho = density difference, lb/ft3 Exercise 9.1 Calculate the pressure difference, i.e., capillary pressure, and capillary rise in an oil-water system from the following data: theta = 30 rhow = 1.0 gm/cm3 rhooil = 0.75 gm/cm3 r = 0.0001 cm sigma = 25 dynes/cm import math theta = 30 rhow = 1.0 # gm/cm3 rhooil = 0.75 #gm/cm3 r = 0.0001 #cm sigma = 25 #dynes/cm Pc = 2* sigma * math.cos(math.pi*theta/180)/r h = 2* sigma * math.cos(math.pi*theta/180)/(r*980.7*(1-0.75)) print(f&#39;capillary pressure : = {Pc} dynes/cm2 &#39;) # Since 1 dyne/cm2 = 1.45 * 10^-5 psi, then capillary pressure : = 433012.70189221937 dynes/cm2 print(f&#39;capillary pressure : = {Pc * 1.45*10**(-5)} psi &#39;) capillary pressure : = 6.278684177437181 psi print(f&#39; Capillary rise : = {h} cm &#39;) Capillary rise : = 1766.1372566216758 cm print(f&#39; Capillary rise : = {h* 0.032808} ft &#39;) Capillary rise : = 57.94343111524393 ft Capillary Hysteresis It is generally agreed that the pore spaces of reservoir rocks were originally filled with water, after which oil moved into the reservoir, displacing some of the water and reducing the water to some residual saturation. When discovered, the reservoir pore spaces are filled with a connatewater saturation and an oil saturation. The process of generating the capillary pressure curve by displacing the wetting phase, i.e., water, with the nonwetting phase (such as with gas or oil), is called the drainage process. The other principal flow process of interest involves reversing the drainage process by displacing the nonwetting phase (such as with oil) with the wetting phase. This displacing process is termed the imbibition process and the resulting curve is termed the capillary pressure imbibition curve. The two capillary pressure-saturation curves are not the same. This difference in the saturating and desaturating of the capillary-pressure curves is closely related to the fact that the advancing and receding contact angles of fluid interfaces on solids are different Initial Saturation Distribution in a Reservoir An important application of the concept of capillary pressures pertains to the fluid distribution in a reservoir prior to its exploitation Figure ?? illustrates an idealized gas, oil, and water distribution in a reservoir. The figure indicates that the saturations are gradually charging from 100% water in the water zone to irreducible water saturation some vertical distance above the water zone. This vertical area is referred to as the transition zone, which must exist in any reservoir where there is a bottom water table. The transition zone is then defined as the vertical thickness over which the water saturation ranges from 100% saturation to irreducible water saturation. The WOC is defined as the uppermost depth in the reservoir where a 100% water saturation exists. It should be noted that there is a difference between the free water level (FWL) and the depth at which 100% water saturation exists. From a reservoir engineering standpoint, the free water level is defined by zero capillary pressure. Obviously, if the largest pore is so large that there is no capillary rise in this size pore, then the free water level and 100% water saturation level, i.e., WOC, will be the same. mathematically \\[\\begin{equation} \\tag{9.5} FWL = WOC + \\frac{144 p_d}{\\Delta \\rho} \\end{equation}\\] where pd = displacement pressure, psi delta rho = density difference, lb/ft3 FWL = free water level, ft WOC = water-oil contact, ft 9.3 Leverett J-Function Capillary pressure data are obtained on small core samples that represent an extremely small part of the reservoir and, therefore, it is necessary to combine all capillary data to classify a particular reservoir. The fact that the capillary pressure-saturation curves of nearly all naturally porous materials have many features in common has led to attempts to devise some general equation describing all such curves. Leverett (1941) approached the problem from the standpoint of dimensional analysis. Realizing that capillary pressure should depend on the porosity, interfacial tension, and mean pore radius, Leverett defined the dimensionless function of saturation, which he called the J-function. \\[\\begin{equation} \\tag{9.6} J(S_w) = 0.21645 \\frac{p_c}{\\sigma} \\sqrt\\frac{k}{\\phi} \\end{equation}\\] where J(Sw) = Leverett J-function pc = capillary pressure, psi sigma = interfacial tension, dynes/cm k = permeability, md phi = fractional porosity Exercise 9.2 A laboratory capillary pressure test was conducted on a core sample taken from the Nameless Field. The core has a porosity and permeability of 16% and 80 md, respectively. The capillary pressure-saturation data are given as follows: Sw = [1.0, 0.8, 0.6, 0.4, 0.2] Pc = [0.5, 0.6, 0.75, 1.05, 1.75] The interfacial tension is measured at 50 dynes/cm. Further reservoir engineering analysis indicated that the reservoir is better described at a porosity value of 19% and an absolute permeability of 120 md. Generate the capillary pressure data for the reservoir. import math Sw = [1.0, 0.8, 0.6, 0.4, 0.2] Pc = [0.5, 0.6, 0.75, 1.05, 1.75] Jsw = [0.21645*(pc /50)*math.sqrt(80/0.16) for pc in Pc] Pc_reservoir = [J*50/(0.21645 * math.sqrt(120/0.19)) for J in Jsw] print(Pc_reservoir ) [0.44487826050130475, 0.5338539126015657, 0.6673173907519571, 0.9342443470527398, 1.5570739117545664] 9.4 Permeability Permeability is a property of the porous medium that measures the capacity and ability of the formation to transmit fluids. The rock permeability, k, is a very important rock property because it controls the directional movement and the flow rate of the reservoir fluids in the formation. This rock characterization was first defined mathematically by Henry Darcy in 1856. In fact, the equation that defines permeability in terms of measurable quantities is called Darcys Law. Darcy developed a fluid flow equation that has since become one of the standard mathematical tools of the petroleum engineer. If a horizontal linear flow of an incompressible fluid is established through a core sample of length L and a cross-section of area A, then the governing fluid flow equation is defined as \\[\\begin{equation} \\tag{9.7} \\nu = - \\frac{k}{\\mu}\\frac{\\Delta P}{\\Delta L} \\end{equation}\\] where v = apparent fluid flowing velocity, cm/sec k = proportionality constant, or permeability, Darcys m = viscosity of the flowing fluid, cp dp/dL = pressure drop per unit length, atm/cm The velocity, v, in Equation (9.7) is not the actual velocity of the flowing fluid but is the apparent velocity determined by dividing the flow rate by the cross-sectional area across which fluid is flowing. Substituting the relationship, q/A, in place of v. \\[\\begin{equation} \\tag{9.8} q = - \\frac{kA}{\\mu}\\frac{\\Delta P}{\\Delta L} \\end{equation}\\] Exercise 9.3 A brine is used to measure the absolute permeability of a core plug. The rock sample is 4 cm long and 3 cm2 in cross section. The brine has a viscosity of 1.0 cp and is flowing a constant rate of 0.5 cm3/sec under a 2.0 atm pressure differential. Calculate the absolute permeability Q = 0.5 A = 3 L = 4 mu = 1 dp = 2 K = Q * mu * L /(dp*A) print(f&#39;Absolute permeability := {K} darcys&#39; ) Absolute permeability := 0.3333333333333333 darcys In using dry gas in measuring the permeability, the gas volumetric flow rate q varies with pressure because the gas is a highly compressible fluid. Therefore, the value of q at the average pressure in the core must be used in Equation (9.8). Assuming the used gases follow the ideal gas behavior (at low pressures), the following relationships apply. The gas flow rate is usually measured at base (atmospheric) pressure pb and, therefore, the term Qgsc is introduced to produce \\[\\begin{equation*} Q_{gsc} P_b = q_m p_m \\end{equation*}\\] Substituting Darcys Law (9.8) in the above expression gives. \\[\\begin{equation*} Q_{gsc} P_b = \\frac{kA(p_1 - p_2)}{\\mu_g L}\\frac{p_1 + p_2}{2} \\end{equation*}\\] or \\[\\begin{equation} \\tag{9.9} Q_{gsc} = \\frac{kA(p^2_{1} - p^2_2)}{2 \\mu_g L P_b} \\end{equation}\\] where k = absolute permeability, Darcys mg = gas viscosity, cp pb = base pressure, atm p1 = inlet (upstream) pressure, atm p2 = outlet (downstream) pressure, atm L = length of the core, cm A = cross-sectional area, cm2 Qgsc = gas flow rate at standard conditions, cm3/sec The Klinkenberg Effect Klinkenberg (1941) discovered that permeability measurements made with air as the flowing fluid showed different results from permeability measurements made with a liquid as the flowing fluid. The permeability of a core sample measured by flowing air is always greater than the permeability obtained when a liquid is the flowing fluid. Klinkenberg postulated, on the basis of his laboratory experiments, that liquids had a zero velocity at the sand grain surface, while gases exhibited some finite velocity at the sand grain surface. In other words, the gases exhibited slippage at the sand grain surface. This slippage resulted in a higher flow rate for the gas at a given pressure differential. The magnitude of the Klinkenberg effect varies with the core permeability and the type of the gas used in the experiment. Klinkenberg suggested a relation between gas permeability and liquid permeability. \\[\\begin{equation} \\tag{9.10} K_g = K_L + bK_L\\frac{1}{p_m} \\end{equation}\\] Jones (1972) studied the gas slip phenomena for a group of cores for which porosity, liquid permeability kL (absolute permeability), and air permeability were determined. He correlated the parameter b with the liquid permeability by the following expression: \\[\\begin{equation} \\tag{9.11} b = 6.9K^{-0.36}_L \\end{equation}\\] by combining (9.10) and (9.11) we get: \\[\\begin{equation} \\tag{9.12} 6.9K^{0.64}_L + p_m K_L -p_g K_g = 0 \\end{equation}\\] This nonlinear equation (9.12) can be solved iteratively. Exercise 9.4 The permeability of a core plug is measured by air. Only one measurement is made at a mean pressure of 2.152 psi. The air permeability is 46.6 md. Estimate the absolute permeability of the core sample. from scipy.optimize import fsolve def fun_Klink(K): pm = 2.152 Kg = 46.6 return 6.9*K[0]**0.64 + pm *K[0] - pm* Kg root = fsolve(fun_Klink, [30]) print(f&#39;Liquid permeability := {root[0]}&#39;) Liquid permeability := 22.849002279471133 9.5 Reservoir Heterogeneity The reservoir heterogeneity is then defined as a variation in reservoir properties as a function of space. Ideally, if the reservoir is homogeneous, measuring a reservoir property at any location will allow us to fully describe the reservoir. The task of reservoir description is very simple for homogeneous reservoirs. On the other hand, if the reservoir is heterogeneous, the reservoir properties vary as a function of a spatial location. These properties may include permeability, porosity, thickness, saturation, faults and fractures, rock facies and rock characteristics. There are essentially two types of heterogeneity: Vertical heterogeneity Areal heterogeneity here we will discuss heterogeneity of the reservoir in terms of permeability. 9.5.1 Vertical Heterogeneity Permeabilities pose problems because they usually vary by more than an order of magnitude between different strata. It is appropriate to be able to describe the degree of heterogeneity within a particular system in quantitative terms. The degree of homogeneity of a reservoir property is a number that characterizes the departure from uniformity or constancy of that particular measured property through the thickness of reservoir. The following are the two most widely used descriptors of the vertical heterogeneity of the formation; Dykstra-Parsons permeability variation V Lorenz coefficient L The Dykstra-Parsons Permeability Variation Dykstra and Parsons (1950) introduced the concept of the permeability variation coefficient V which is a statistical measure of non-uniformity of a set of data. It is generally applied to the property of permeability but can be extended to treat other rock properties. It is generally recognized that the permeability data are log-normally distributed. Dykstra and Parsons recognized that the geologic processes that create permeability in reservoir rocks appear to leave permeabilities distributed around the geometric mean. The required computational steps for determining the coefficient V are summarized below: Arrange the core samples in decreasing permeability sequence For each sample, calculate the percentage of thickness with permeability greater than this sample plot permeability values on the log scale and the % of thickness on the probability scale Draw the best straight line through the points Read the corresponding permeability values at 84.1% and 50% of thickness The Dykstra-Parsons permeability variation is defined follows \\[\\begin{equation} \\tag{9.13} V = \\frac{K_{50}-K_{84.1}}{K_{50}} \\end{equation}\\] Exercise 9.5 Calculate the Dykstra-Parsons permeability variation for the following data: K = [435.0, 254.0, 196.0, 172.0, 166.0, 158.0, 153.0, 147.0, 128.0, 105.0, 100.0, 91.0, 90.0, 83.0, 72.0 , 62.0, 49.0, 44.0, 40.0, 35.0, 32.0, 30.0, 28.0, 27.0, 20.0, 9.0] h = [2.0, 2.0, 2.0, 3.0, 2.0, 2.0, 2.0, 2.0, 1.0, 2.0, 1.0, 2.5, 2.5, 2.0, 1.5, 2.0, 6.5, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0] from numpy import cumsum import math from scipy.optimize import curve_fit K = [435.0, 254.0, 196.0, 172.0, 166.0, 158.0, 153.0, 147.0, 128.0, 105.0, 100.0, 91.0, 90.0, 83.0, 72.0 , 62.0, 49.0, 44.0, 40.0, 35.0, 32.0, 30.0, 28.0, 27.0, 20.0, 9.0] h = [2.0, 2.0, 2.0, 3.0, 2.0, 2.0, 2.0, 2.0, 1.0, 2.0, 1.0, 2.5, 2.5, 2.0, 1.5, 2.0, 6.5, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0] cum_h = list(cumsum(h)) max_h = max(cum_h) percent_h = [x*100/max_h for x in cum_h] sublist_K = [math.log(K[idx]) for idx in range(len(percent_h)) if (percent_h[idx]&gt;40) &amp; (percent_h[idx]&lt;90) ] sublist_h = [percent_h[idx] for idx in range(len(percent_h)) if (percent_h[idx]&gt;40) &amp; (percent_h[idx]&lt;90) ] def line(x, a, b): return a*x + b popt, _ = curve_fit(line, sublist_h, sublist_K) K_50 = math.exp(line(50, popt[0], popt[1])) K_84 = math.exp(line(84.1, popt[0], popt[1])) print(K_50) 77.69782663556242 print(K_84) 31.19170566168342 V = (K_50- K_84)/K_50 print(V) 0.5985511176781497 It should be noted that if all the permeabilities are equal, the numerator or (9.13) would be zero, and the V would also be zero. This would be the case for a completely homogeneous system. Lorenz Coefficient L Schmalz and Rahme (1950) introduced a single parameter that describes the degree of heterogeneity within a pay zone section. The term is called Lorenz coefficient and varies between zero, for a completely homogeneous system, to one for a completely heterogeneous system. The following steps summarize the methodology of calculating Lorenz coefficient. - Arrange all the available permeability values in a descending order. - Calculate the cumulative permeability capacity and cumulative volume capacity - Calculate the cumulative permeability capacity Skh and cumulative volume capacity. - Plot the normalized cumulative permeability capacity versus the normalized cumulative volume capacity on a Cartesian scale. A completely uniform system would have all permeabilitys equal, and a plot of the normalized capacities would be a straight line. The plot can be used to describe the reservoir heterogeneity quantitatively by calculating the Lorenz coefficient. The coefficient is defined by the following expression: L = Area above straight line / Area below straight line for homogeneous reservoir Area above straight line is zero hence L=0 and for completely heterogeneous reservoir area above = area below thus L=1; Exercise 9.6 Using data given in exercise 9.5 calculate Lorenz Coefficient. from scipy import integrate KH = [K[i]*h[i] for i in range(len(h))] Norm_KH = [(max(KH)-KH[i])/(max(KH)-min(KH)) for i in range(len(h))] Norm_h = [(percent_h[i]- min(percent_h))/(max(percent_h)-min(percent_h)) for i in range(len(h))] Area = integrate.simpson(Norm_KH, Norm_h) print(Area) 0.7621997578319712 L = (Area - 0.5)/0.5 print(L) 0.5243995156639425 "],["relative-permeability.html", "10 Relative Permeability 10.1 Three-phase relative permeability 10.2 Simplified Fractional Flow Equation 10.3 Buckley-Leverett Theory", " 10 Relative Permeability The effective permeability of any reservoir fluid is a function of the reservoir fluid saturation and the wetting characteristics of the formation Relative Permeability from Analytical Equations Analytical representations for individual-phase relative permeabilities are commonly used in numerical simulators Oil-Water Systems \\[\\begin{equation} \\tag{10.1} K_{ro} = (K_{ro})_{sc} \\Big[\\frac{1- S_w - S_{orw}}{1 - S_{wc} - S_{orw}} \\Big]^{n_o} \\end{equation}\\] \\[\\begin{equation} \\tag{10.2} K_{rw} = (K_{rw})_{sorw} \\Big[\\frac{S_w - S_{wc}}{1 - S_{wc} - S_{orw}} \\Big]^{n_w} \\end{equation}\\] Currey Function fitting on experimental data Exercise 10.1 Fit Relative permeability curve on Analytical Equations (10.1) and (10.2) for the given end points and calculate the coefficients no and nw for oil and water. from scipy import optimize import pandas as pd import matplotlib.pyplot as plt Swc = 0.25 Swor = 0.35 Kro = 0.85 # kro at Swc Krw= 0.4 # Krw at Sorw def get_Ko(Sw, no): return Kro*((1-Sw-Swor)/(1-Swc-Swor))**no def get_Kw(Sw, nw): return Krw*((Sw-Swc)/(1-Swc-Swor))**nw df = pd.read_csv(&#39;data/Rel-Perm.csv&#39;) df[&#39;Ratio_Ko_kw&#39;] = df[&#39;Ko&#39;]/df[&#39;Kw&#39;] def test_func(Sw, no, nw): return Kro/Krw*(1-Swc-Swor)**(nw-no)*(1-Sw-Swor)**no/(Sw-Swc)**nw params, params_covariance = optimize.curve_fit(test_func, df[&#39;Sw&#39;], df[&#39;Ratio_Ko_kw&#39;],p0=[1.5, 4]) fig = plt.figure(figsize=(20, 10)) plt.plot(df[&#39;Sw&#39;], df[&#39;Ko&#39;], &#39;k^&#39;, ) plt.plot(df[&#39;Sw&#39;], df[&#39;Kw&#39;],&#39;k.&#39;) plt.xlim([0,1]) plt.ylim([0,1]) plt.plot(df[&#39;Sw&#39;], get_Ko(df[&#39;Sw&#39;], params[0]), &#39;r--&#39;) plt.plot(df[&#39;Sw&#39;], get_Kw(df[&#39;Sw&#39;], params[1]), &#39;b--&#39;) plt.legend((&#39;Ko&#39;, &#39;Kw&#39;, &#39;Ko fitted no = &#39; + str(round(params[0], 2)),&#39;Kw fitted nw = &#39;+ str(round(params[1], 2)) ),loc=&#39;upper center&#39;) plt.show() Exercise 10.2 Fit Relative permeability curve on the core data and generate calculate Kro and Krw at Sw = 0.567 # suppose we have experimental data of relative permeability and we want to curve fit on this data. from scipy import interpolate Sw = np.arange(0.2, 0.9, 0.05) krw = np.array([0, .002, .02, .04, .07, .11, .15, .22, .3, .4, .5, .6, .7, .8]) kro = np.array([.6, .5, .4, .3, .23, .17, .12, .08, .05, .03, .02, .01, .005, 0]) # Spline interpolation of data krw_interp = interpolate.splrep(Sw, krw, s=0) kro_interp = interpolate.splrep(Sw, kro, s=0) def get_Kro_Krw_at_sw(Sw_new): krw_new = interpolate.splev(Sw_new, krw_interp, der=0) kro_new = interpolate.splev(Sw_new, kro_interp, der=0) return krw_new, kro_new Sw_given = 0.567 # we want to find Kro and Krw at this saturation krw_cal, kro_cal = get_Kro_Krw_at_sw( Sw_given) print(f&#39;at given Sw : {Sw_given} Kro := {kro_cal} &amp; Krw := {krw_cal}&#39;) at given Sw : 0.567 Kro := 0.06870642488480108 &amp; Krw := 0.2458867331261035 10.1 Three-phase relative permeability In a three-phase system it is found that the relative permeability to water depends only upon the water saturation. Wyllies Correlations Wyllie (1961) proposed the following equations for three-phase relative permeabilities in a water-wet system: Calculate Fw curve The fractional flow of water is the ratio of water production rate to total production rate. In the case of an oil-water system, the fractional flow of water is given by: \\[\\begin{equation} f_{w} = \\frac{q_{w}}{q_{w} + q_{o} } \\tag{10.3} \\end{equation}\\] Notice that the flow rates are expressed in terms of reservoir volumes. The fractional flow of oil fw, and the fractional flow of water are related by fw= 1 - fw for an oil-water system. Based on the definition of fractional flow, we see that fractional flow should be a value between 0 and 1. 10.2 Simplified Fractional Flow Equation A simplified fractional flow equation is obtained by replacing flow rates with Darcys Law in the definition of fractional flow. If we neglect capillary pressure and gravity for simplicity, we obtain \\[\\begin{equation} q_{w} = \\frac{kk_{r_{w}}A}{\\mu_{w}}\\frac{\\partial P_{w}}{\\partial x} \\tag{10.4} \\end{equation}\\] where A is cross-sectional area and P is pressure of phase. Since capillary pressure is neglected, we have equal phase pressure so Pw = Po. if we put (10.4) in fractional flow equation given (10.3) and simplify it we will get \\[\\begin{equation} \\tag{10.5} f_{w} = \\frac{\\frac{k_{r_{w}}}{\\mu_{w}}}{\\frac{k_{r_{w}}}{\\mu_{w}} + \\frac{k_{r_{o}}}{\\mu_{o}}} \\end{equation}\\] Mobility of a phase can be defined as \\[\\begin{equation} \\tag{10.6} \\lambda_{w} = \\frac{k_{r_{w}}}{\\mu_{w}} \\end{equation}\\] expressing (10.5) in term of (10.6) \\[\\begin{equation} \\tag{10.7} f_{w} = \\frac{1}{1 + \\frac{\\lambda_{o}}{\\lambda_{w}}} \\end{equation}\\] # taking the data from above Sw = np.arange(0.2, 0.9, 0.01) muo = 0.25 # cp muw = 1 # cp Fw = list() for i in range (len(Sw)): krw_cal, kro_cal = get_Kro_Krw_at_sw( Sw[i]) if krw_cal == 0: Fw.append(0) else: Fw.append(1 / (1 + (kro_cal / muo) * (muw / krw_cal))) fig = plt.figure(figsize=(20, 10)) plt.plot(Sw, Fw, &#39;b-&#39;, ) plt.xlim([0,1]) plt.ylim([0,1]) plt.ylabel(&#39;fraction flow&#39;) plt.xlabel(&#39;Sw&#39;) plt.title(&#39;Fraction flow curve&#39;) plt.show() Calculate Fw Equation with Gravity Gravity can be included in the fractional flow equation as follows. First, let us consider the two-phase flow of oil and water in a tilted linear system. Darcys Law including capillary pressure and gravity effects for linear flow is \\[\\begin{equation} q_{w} = - \\frac{kk_{r_{w}}A}{\\mu_{w}}\\Bigg(\\frac{\\partial P_{w}}{\\partial x} + \\rho_{w}g\\sin\\alpha \\Bigg) \\\\ q_{o} = - \\frac{kk_{r_{o}}A}{\\mu_{o}}\\Bigg(\\frac{\\partial P_{o}}{\\partial x} + \\rho_{o}g\\sin\\alpha&#39; \\Bigg) \\tag{10.8} \\end{equation}\\] If we differentiate capillary pressure for a water-wet system with respect to position x along the dipping bed, we find \\[\\begin{equation} \\tag{10.9} \\frac{\\partial P_{cow}}{\\partial x} = \\frac{\\partial P_{o}}{\\partial x} -\\frac{\\partial P_{w}}{\\partial x} \\end{equation}\\] Rearranging and collecting terms gives the fractional flow to water fw in conventional oilfield units: \\[\\begin{equation} \\tag{10.10} f_{w} = \\frac{1+0.001127 \\frac{Akk_{ro}}{\\mu_{o}q_{t}}\\Big(\\frac{\\partial P_{cow}}{\\partial x} - 0.433(\\gamma_{w} - \\gamma_{o})\\sin\\alpha \\Big)}{1 + \\frac{k_{ro}}{k_{rw}}\\frac{\\mu_{w}}{\\mu_{o}}} \\end{equation}\\] where A cross-sectional area of flow system ft2, k absolute permeability md, kro relative permeability to oil, kw relative permeability to water, oil viscosity cp, water viscosity cp, Pcow oil-water capillary pressure psi = P0 - Pw, x direction of linear flow ft, alpha dip angle of formation degrees, gamma oil specific gravity (water =1), gamma water specific gravity (water = 1 ), 10.3 Buckley-Leverett Theory One of the simplest and most widely used methods of estimating the advance of a fluid displacement front in an immiscible displacement process is the Buckley-Leverett method. Buckley-Leverett Theory [1942] estimates the rate at which an injected water bank moves through a porous medium. The approach uses fractional flow theory and is based on the following assumptions: Flow is linear and horizontal Water is injected into an oil reservoir Oil and water are both incompressible Oil and water are immiscible Gravity and capillary pressure effects are negligible Frontal advance theory is an application of the law of conservation of mass. Flow through a small volume element with length x and cross-sectional area A The change in water saturation per unit time can be written as \\[\\begin{equation} \\tag{10.11} \\frac{\\partial S_{w}}{\\partial t} = \\frac{-q}{A \\phi} \\frac{\\partial f_{w}}{\\partial S_{w}}\\frac{\\partial S_{w}}{\\partial x} \\end{equation}\\] The python code to solve BL curve is given below def buckley_leverett1d(nt, Sw0, L, nx, sigma, bc_value, muw, muo, q, A, poro, Sw_data, krw_data, kro_data): &quot;&quot;&quot; Solve Buckley-Leverett PDE using forward-time/backward-space scheme &quot;&quot;&quot; def interstitial_velocity(q, A, poro): # interstitial velocity vt vt = q / A * poro return vt def fractional_flow(krw, muw, kro, muo): # fractional flow Fww Fww = 1 / (1 + (kro / muo) * (muw / krw)) return Fww # calculate interstitial velocity vt = interstitial_velocity(q, A, poro) # calculate dx dx = L / (nx - 1) # calculate dt from CFwL dt = sigma * dx / vt # time-step size # Discretize the domain. x = np.linspace(0.0, L, num=nx) # integrate solution in time Sw_hist = [Sw0.copy()] Sw = Sw0.copy() for n in range(nt): # Compute the fractional flow. krw, kro = get_Kro_Krw_at_sw(Sw) Fw = fractional_flow(krw, muw, kro, muo) # Advance in time. Sw[1:] = Sw[1:] - (vt * dt / dx) * (Fw[1:] - Fw[:-1]) # Set the left boundary condition. Sw[0] = bc_value # Record the time-step solution. Sw_hist.append(Sw.copy()) # Plot Sw over x # fig = pyplot.figure(figsize=(6.0, 4.0)) plt.xlabel(r&#39;$x$&#39;) plt.ylabel(r&#39;Sw&#39;) plt.grid() plt.plot(x, Sw0, label=&#39;Initial&#39;, color=&#39;C0&#39;, linestyle=&#39;--&#39;, linewidth=2) plt.plot(x, Sw, label=&#39;nt = {}&#39;.format(nt), color=&#39;C1&#39;, linestyle=&#39;-&#39;, linewidth=2) plt.xlim(0.0, L) plt.ylim(0, 1) plt.legend() plt.grid() Sw = np.arange(0.2, 0.9, 0.05) krw = np.array([0, .002, .02, .04, .07, .11, .15, .22, .3, .4, .5, .6, .7, .8]) kro = np.array([.6, .5, .4, .3, .23, .17, .12, .08, .05, .03, .02, .01, .005, 0]) # set parameters for initial condition L = 40 nx = 401 x = np.linspace(0.0, L, nx) Sw0 = np.full(nx, 0.2) Sw0[:15] = 1 plt.plot(x, Sw0) plt.xlim(min(x), max(x)) plt.xlabel(&#39;x&#39;); plt.ylabel(&#39;Sw&#39;) plt.title(&#39;Initial Condition&#39;, size=20) plt.show() # Set parameters for simulation nt = 70 # L = 4 sigma = 0.1 bc_value = Sw0[0] u_max = 1 muw = 0.5E-3 muo = 1E-3 q = 200 # m3/hr A = 30 # m2 poro = 0.24 # Simulation nt = [10, 500, 700, 900, 1200, 2000] plt.figure(figsize=(16,9)) for i in range(len(nt)): plt.subplot(3,2,i+1) buckley_leverett1d(nt[i], Sw0, L, nx, sigma, bc_value, muw, muo, q, A, poro, Sw, krw, kro) plt.show() "],["fundamentals-of-fluid-flow-in-reservoirs.html", "11 Fundamentals of fluid flow in Reservoirs 11.1 Type of fluids in reservoir 11.2 Fluid flow equation", " 11 Fundamentals of fluid flow in Reservoirs Flow in porous media is a very complex phenomenon and as such cannot be described as explicitly as flow through pipes or conduits. It is rather easy to measure the length and diameter of a pipe and compute its flow capacity as a function of pressure; in porous media, however, flow is different in that there are no clear-cut flow paths. The main objective of this chapter is to present the mathematical relationships (along with python codes) that are designed to describe the flow behavior of the reservoir fluids. The mathematical forms of these relationships will vary depending upon the characteristics of the reservoir. The main characteristic on which fluid flow depends are: Types of fluids in the reservoir Flow regime Reservoir geometry Number of flowing fluid in the reservoir 11.1 Type of fluids in reservoir The isothermal compressibility coefficient is essentially the controlling factor in identifying the type of the reservoir fluid. In general, reservoir fluids are classified into three groups: Incompressible fluids Slightly compressible fluids Compressible fluids the isothermal compressibility coefficient c is described mathematically by the following two equivalent expressions: In volume term \\[\\begin{equation} \\tag{11.1} c = \\frac{-1}{V} \\frac{\\partial V}{\\partial p} \\end{equation}\\] In terms of fluid density \\[\\begin{equation} \\tag{11.2} c = \\frac{-1}{\\rho} \\frac{\\partial \\rho}{\\partial p} \\end{equation}\\] 11.2 Fluid flow equation The fluid flow equations that are used to describe the flow behavior in a reservoir can take many forms depending upon the combination of variables. By combining the conservation of mass equation with the transport equation (Darcys equation) (9.8) and various equations-of-state, the necessary flow equations can be developed. The negative sign in Equation (9.8) is added because the pressure gradient is negative in the direction of flow as shown in Figure 6-9. For a horizontal-radial system, the pressure gradient is positive "],["pattern-floods.html", "12 Pattern Floods 12.1 Recovery Efficiency 12.2 Pattern Recovery 12.3 aa", " 12 Pattern Floods The effectiveness of a displacement process depends on many factors. These factors include reservoir and fluid characteristics that are beyond our control, such as depth, structure, and fluid type. Other factors that influence displacement efficiency can be controlled, however. They include the number and type of wells, well rates, and well locations. The distribution of wells is known as the well pattern. The impact of well pattern on displacement effectiveness is discussed after definitions of recovery efficiency are presented. 12.1 Recovery Efficiency Recovery efficiency is quantified by comparing initial and final volumes of fluid in place. It takes into account volumetric and displacement efficiencies. The different aspects of recovery efficiency are defined and then combined to form overall recovery efficiency. Displacement efficiency accounts for the efficiency of recovering mobile hydrocarbon. To be specific, we define displacement efficiency for oil as the ratio of mobile oil to original oil in place at reservoir conditions \\[\\begin{equation} \\tag{12.1} E_{D} = \\frac{S_{oi} - S_{or}}{S_{oi}} \\end{equation}\\] Displacement efficiency is a measure of how effectively mobile hydrocarbons can be recovered. In addition to displacement efficiency, volumetric factors are needed to determine overall recovery efficiency. Areal and vertical sweep efficiencies are defined by \\[\\begin{equation} \\tag{12.2} E_{A} = \\frac{Sweep Area}{Total Area} \\\\ E_{V} = \\frac{Sweep Thickness}{Total Thickness} \\end{equation}\\] Reservoir flow models are useful tools for quantifying both swept area and swept thickness. The product of areal and vertical sweep efficiency is the volumetric sweep efficiency \\[\\begin{equation} \\tag{12.3} E_{vol} = E_{A}E_{V} \\end{equation}\\] Overall recovery efficiency must account for both volumetric and displacement effects. It is therefore defined as the product of volumetric sweep efficiency and displacement efficiency. Notice that each of the efficiency factors in recovery efficiency can be relatively large,, and yet recovery efficiency will be relatively small. For example, suppose the areal and vertical efficiencies are each 70% and displacement efficiency is 80%, the product of these efficiencies is approximately 39%. This means that even the reservoirs with the best recovery efficiency often have a substantial volume of unrecovered hydrocarbon remaining in the ground. The most important goal of improved recovery techniques is to recover this remaining resource 12.1.1 Patterns and Spacing The alignment of the injector-producer pair represents a linear displacement process. It is the simplest pattern involving injection and production wells. A variety of other patterns may be defined by alining Injector producer pairs. The ratio of the number of producing wells to the number of injection wells is shown in Table 7-1. The patterns depicted in Table 7-1 and Figure 7-1 are symmetric patterns that are especially effective for reservoirs with relatively small dip and large areal extent. The injectors and producers are generally interspersed. Other patterns in which injectors and producers are grouped together may be needed for reservoirs with significant dip. For example, a peripheral or flank injection pattern may be needed to effectively flood an anticlinal or monoclinal reservoir Table 12.1: Producer-to-Injector Ratios for Common Well Patterns Well Pattern Producer : Injector Ratio 1. Four-Spot 2 2. Five-Spot 1 3. Direct Line-drive 1 4. Staggered Line-drive 1 5. Seven-Spot 1/2 6 Nine- Spot 1/3 The location of injection wells depends on factors such as reservoir structure, injected fluid type, and displacement mechanism. For example, up structure gas injection can be an effective displacement process for producing a monoclinal reservoir containing oil. It relies on the movement of a gas-oil contact and the displacement of oil to down structure production wells. On the other hand, down structure peripheral injection of water can be used to displace oil to up structure producers in an anticlinal reservoir. In this case, down structure water injection is used to move the oil-water contact up structure and displace oil to up structure production wells. The same displacement concept applies to production of an anticlinal oil reservoir with strong aquifer support. In addition to reservoir geometry and displacement process, the well pattern depends on the distribution of existing production wells and the desired spacing of wells. Well spacing is an estimate of the area being drained by a production well. A reduction in well spacing requires an increase in the density of production wells. The density of production wells is the number of production wells in a specified area. Well density can be increased by drilling additional wells in the space between wells in a process called infill drilling. Infill drilling is an effective means of altering flow patterns and improving recovery efficiency, but can be more expensive than a fluid displacement process. The selection of a development plan depends on a comparison of the economics of alternative development concepts. Reservoir models are especially useful tools for performing these studies. 12.2 Pattern Recovery Optimum performance may be achieved with the patterns defined in the previous section by controlling the rates of injectors and producers. These calculations can be performed analytically if we assume the displacing and displaced fluids are incompressible, the mobility ratio is one, and the reservoir has uniform properties. Values of injection rates for the three patterns. The calculation of analytical injection rates, even under a set of restrictive assumptions, provides a methodology for designing well patterns without using a reservoir simulator. More accurate estimates of injection rates under a less restrictive set of assumptions are obtained using reservoir simulators. For example, simulators have been used to correlate volumetric sweep efficiency with mobility ratio and permeability variation in a reservoir that is being subjected to a pattern flood. One measure of permeability variation is the Dykstra-Parsons coefficient of permeability variation. The Dykstra-Parsons coefficient can be estimated for a log-normal permeability distribution as \\[\\begin{equation} \\tag{12.4} V_{DP} = 1- exp\\Big( - \\sqrt {ln \\Big(\\frac{K_{A}}{K_{H}}\\Big)} \\Big) \\end{equation}\\] where \\[\\begin{equation} \\tag{12.5} K_{A} = \\frac{1}{n} \\displaystyle\\sum_{i=1}^{n} K_i \\\\ K_{H} = \\frac{1}{n} \\displaystyle\\sum_{i=1}^{n} \\frac{1}{K_i} \\end{equation}\\] The Dykstra-Parsons coefficient should be in the range 0 &lt; VDP &lt; 1. For a perfectly homogeneous reservoir, VDP = 0 because KA = KH. An increase in reservoir heterogeneity increases VDP. Typical values of the Dykstra-Parsons coefficient are in the range 0.4 &lt; VDP &lt; 0.9. import math as M # let&#39;s take the layer-wise permeability data of an arbitrary reservoir K = [365.0, 275.0, 165.0, 121.0, 73.0, 37.0, 19.0, 9.3, 3.5, 1.9] # md # Calculate KA KA = sum(K) / len(K) KH = sum([1/k for k in K])/len(K) VDP = 1- M.exp(-M.sqrt(M.log(KA/KH))) print(VDP) 0.9282653209184065 12.3 aa "],["pressure-transient-analysis.html", "13 Pressure Transient Analysis", " 13 Pressure Transient Analysis Pressure is good "],["volumetrics.html", "14 Volumetrics 14.1 Calculating the Gas inplace by volumetric methods", " 14 Volumetrics 14.1 Calculating the Gas inplace by volumetric methods The standard cubic feet gas inplace, G is given by: \\[\\begin{equation} G = \\frac{43,560 V_{b} \\phi (1-S_{w})}{B_{g}} \\end{equation}\\] Contour Methods using trangulation mmethods # Tricontour (triangulation) method&quot; import matplotlib.tri as tri import matplotlib.pyplot as plt import matplotlib.cm as cm import numpy as np import pandas as pd import math from scipy.interpolate import griddata # data welldat = pd.read_csv(&#39;data/data_volumetrics.csv&#39;) x, y, z = welldat.x, welldat.y, welldat.z triang = tri.Triangulation(x, y) #----------------------------------------------------------------------------- # Refine data #----------------------------------------------------------------------------- refiner = tri.UniformTriRefiner(triang) tri_refi, z_test_refi = refiner.refine_field(z, subdiv=5) #----------------------------------------------------------------------------- # Plot the triangulation and the high-res iso-contours #----------------------------------------------------------------------------- plt.figure(figsize=(20, 20)) &lt;Figure size 2000x2000 with 0 Axes&gt; plt.gca().set_aspect(&#39;equal&#39;) plt.triplot(triang, lw=0.5, color=&#39;white&#39;) [&lt;matplotlib.lines.Line2D object at 0x0000000030897D90&gt;, &lt;matplotlib.lines.Line2D object at 0x000000003118CFD0&gt;] levels = np.linspace(min(z)+10, max(z)-10, 10) ##contour range, divided by 10 levels cmap = cm.get_cmap(name=&#39;terrain&#39;, lut=None) fig = plt.tricontourf(tri_refi, z_test_refi, levels=levels, cmap=cmap) fig = plt.tricontour(tri_refi, z_test_refi, levels=levels, colors=[&#39;0.25&#39;, &#39;0.5&#39;, &#39;0.5&#39;, &#39;0.5&#39;, &#39;0.5&#39;], linewidths=[1.0, 0.5, 0.5, 0.5, 0.5]) plt.plot(x, y, &#39;ko&#39;, ms=3) # plot the well points [&lt;matplotlib.lines.Line2D object at 0x000000003088A880&gt;] plt.clabel(fig, fig.levels[::5], inline=1, fontsize=10) # give labels for contours, fig.levels[::x] controls the frequency of labels # lesser ::x, more populated by labels &lt;a list of 4 text.Text objects&gt; plt.title(&quot;Structure Map using Triangulation Method&quot;, pad=10, size=20) Text(0.5, 1.0, &#39;Structure Map using Triangulation Method&#39;) plt.show() "],["gas-and-water-coning.html", "15 Gas and Water Coning 15.1 Coning in Vertical wells 15.2 Coning in Horizontal wells", " 15 Gas and Water Coning Coning is a term used to describe the mechanism of upward movement of Water or downward movement of Gas into the producing well. 15.1 Coning in Vertical wells 15.1.1 Meyer-Garder Correlation In 1954 Meyer and Garder suggested following relation in Gas Oil Coning System import math #Sample Data Kh = 110 #md Kro = 0.85 # oil relative permeability po = 47.5 # lb/ft3 (oil Density) pg = 5.1 # lb/ft3 (gas Density) mu= 0.73 # cp (Oil viscosity) fvf = 1.1 # bbl/STB h = 40 #ft (oil column thickness) hp = 15 #ft (perforation interval) Dt = 25 # ft (depth of GOC from top of perforation) rw = 0.25 #ft (wellbore radius) re = 660 # ft (drainage radius) Qc = 0.0000246*(po-pg)*(Kh*Kro/(mu*fvf))*(h**2-(h-Dt)**2)/math.log(re/rw) print(f&#39;Critical Oil rate = {Qc} STB/day&#39;) Critical Oil rate = 21.19601914346511 STB/day for Oil water system: #same data as above example pw = 63.76 # lb/ft3 (water Density) Qc = 0.0000246*(pw-po)*(Kh*Kro/(mu*fvf))*(h**2-hp**2)/math.log(re/rw) print(f&#39;Critical Oil rate = {Qc} STB/day&#39;) Critical Oil rate = 8.12847337907412 STB/day for gas Oil water system: #same data as above example h = 65 #ft (oil column thickness) Qc = 0.0000246*(Kh*Kro/(mu*fvf))*((h**2-hp**2)/math.log(re/rw))*((pw-po)*((po-pg)/(pw-pg))**2+((po-pg)*(1-(po-pg)/(pw-pg))**2)) print(f&#39;Critical Oil rate = {Qc} STB/day&#39;) Critical Oil rate = 17.091889596019843 STB/day 15.2 Coning in Horizontal wells "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
