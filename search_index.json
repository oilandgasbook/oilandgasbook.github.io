[["index.html", "Applications of Python in Reservoir Engineering 1 License", " Applications of Python in Reservoir Engineering Pramod Azad 1 License This work is licensed under a Creative Commons Attribution 4.0 International License. Copyright Citation BibTex If you use this repository for a certain purpose, please make this citation BibTex registry: @misc{pramodazad, author = {Pramod Azad}, title = {Applications of Python in Reservoir Engineering}, year = {2024}, publisher = {GitHub}, journal = {GitHub repository}, } "],["introduction-to-python-for-reservoir-engineering.html", "2 Introduction to Python for Reservoir Engineering 2.1 Why Python? 2.2 Versatility 2.3 Readability and Learnability 2.4 Open Source Community 2.5 Extensive Libraries 2.6 Conclusion: Python’s Role in Reservoir Engineering 2.7 Getting Started with Python 2.8 Setting Up Your Python Environment", " 2 Introduction to Python for Reservoir Engineering 2.1 Why Python? Python has emerged as the go-to programming language for engineers, scientists, and data analysts, and it’s not without reason. Its versatility, ease of use, and a thriving ecosystem of libraries make it a powerful tool for reservoir engineering and beyond. 2.2 Versatility Python’s versatility is a major draw for engineers in the oil and gas industry. Whether you’re working on data analysis, numerical simulations, data visualization, or machine learning, Python has libraries and frameworks to support your needs. This adaptability means you can seamlessly transition from one aspect of reservoir engineering to another within the same programming environment. Python’s versatility is a defining feature that makes it particularly well-suited for reservoir engineering and various other scientific disciplines. Its broad range of applications spans from data analysis and visualization to numerical simulations and machine learning. In reservoir engineering, this versatility is invaluable because it allows engineers to employ a single programming language throughout the entire workflow, promoting efficiency and consistency. One key aspect of Python’s versatility is its ability to seamlessly integrate with other technologies and tools commonly used in the oil and gas industry. Python’s ease of interfacing with databases, spreadsheets, and external software systems simplifies data extraction, transformation, and loading (ETL) processes. Engineers can readily connect Python scripts to industry-specific software, enhancing automation and data analysis capabilities. Moreover, Python’s cross-platform compatibility ensures that code developed on one operating system can run on others without major modifications. This feature streamlines collaboration among engineers and organizations, as it reduces compatibility issues and promotes code reusability. Python’s adaptability extends to the creation of custom applications and graphical user interfaces (GUIs). Engineers can develop tailored tools and dashboards for specific reservoir engineering tasks, providing a user-friendly interface for data analysis and decision-making. In summary, Python’s versatility empowers reservoir engineers to tackle a wide range of tasks within a unified programming environment. Its compatibility, integration capabilities, and extensibility make it an invaluable tool for addressing the multifaceted challenges of reservoir engineering. 2.3 Readability and Learnability Python’s elegance lies not only in its versatility but also in its unparalleled readability and learnability. These characteristics set it apart as a programming language suitable for engineers and scientists, even those without extensive coding backgrounds. Reservoir engineers can swiftly grasp Python’s syntax and structure, which minimizes the learning curve and allows them to focus on solving engineering challenges. The simplicity of Python’s code syntax, which emphasizes clean and meaningful indentation, is a pivotal factor. Code blocks are organized by indentation rather than cumbersome braces or keywords, making it remarkably easy to read and comprehend. This feature is invaluable for reservoir engineers who want to collaborate effectively, as it promotes code consistency and reduces the risk of errors. Additionally, Python’s human-friendly nature extends to its extensive and self-explanatory standard libraries. Engineers can often accomplish complex tasks using straightforward functions and modules, reducing the need for writing intricate, low-level code. This approach is especially advantageous in reservoir engineering, where time and accuracy are of the essence. Python’s learnability further accelerates the adoption of programming skills among engineers. Its supportive community, extensive documentation, and myriad of online resources facilitate the journey of mastering Python. Engineers can quickly find answers to questions, access tutorials, and leverage examples to apply Python effectively to reservoir engineering challenges. In essence, Python’s readability and learnability are instrumental in making it an accessible and efficient tool for reservoir engineers, enabling them to focus on the engineering aspects of their work while embracing the power of programming. 2.4 Open Source Community One of Python’s most remarkable strengths lies in its thriving open-source community. This community is a dynamic ecosystem of developers, researchers, engineers, and enthusiasts who contribute to the growth and improvement of the Python programming language and its associated libraries. For reservoir engineers and professionals in the oil and gas industry, this collaborative environment is a treasure trove of resources and support. The open-source nature of Python ensures that it remains accessible to everyone, without licensing restrictions or costly fees. Engineers can freely install and use Python on their machines, making it a cost-effective choice for both individuals and organizations. Moreover, the absence of vendor lock-in fosters an environment of innovation and continuous improvement. Within the Python community, a vast array of libraries and packages are readily available for reservoir engineering tasks. Whether it’s specialized libraries for data analysis, numerical simulations, or geospatial data processing, chances are there’s an open-source Python package that can expedite your work. The collaborative spirit of the community ensures that these packages are constantly updated and enhanced, providing engineers with state-of-the-art tools for their projects. Additionally, the Python community is known for its strong emphasis on knowledge sharing and support. Engineers can find answers to questions on forums, access comprehensive documentation, and participate in open-source projects. This collective wisdom and willingness to help fellow engineers make Python an inviting and empowering language for those in the reservoir engineering field. In summary, Python’s open-source community is a vital asset for reservoir engineers, offering a wealth of resources, cost-effective solutions, and a supportive network of experts. This collaborative ecosystem amplifies Python’s capabilities and enhances its suitability for tackling the challenges of the oil and gas industry. 2.5 Extensive Libraries Python’s prowess in reservoir engineering is significantly bolstered by its extensive libraries, specifically tailored for scientific and engineering applications. These libraries provide reservoir engineers with a rich toolbox of pre-built functions, modules, and tools designed to simplify complex tasks and streamline workflows. Among these libraries, NumPy stands out as a fundamental building block. NumPy’s array-based computing capabilities facilitate efficient numerical operations, making it ideal for tasks like reservoir data analysis, linear algebra, and statistical computations. Its multi-dimensional array structure is particularly useful for handling large datasets common in reservoir engineering. Pandas is another indispensable library that excels in data manipulation and analysis. Reservoir engineers can leverage Pandas to effortlessly load, clean, and transform reservoir data, facilitating advanced analytics and visualization. Its intuitive DataFrame data structure allows for easy indexing, filtering, and grouping, empowering engineers to extract valuable insights from their data. When it comes to visualizing reservoir data, Matplotlib emerges as a reliable companion. This library offers a wide range of customizable plotting options, enabling engineers to create informative and publication-quality visualizations. From well logs to reservoir performance graphs, Matplotlib transforms data into insightful visuals that aid in decision-making. SciPy, as a scientific computing library, further expands Python’s capabilities for reservoir engineering. Engineers can harness SciPy’s functionalities for solving complex mathematical equations, numerical optimization, and interpolation. Its integration with NumPy and Matplotlib makes it a seamless addition to the Python ecosystem. In essence, Python’s extensive libraries for scientific and engineering applications provide reservoir engineers with the tools they need to address intricate challenges effectively. These libraries not only reduce development time but also ensure code reliability, enabling engineers to focus on the analysis and decision-making aspects of reservoir engineering. 2.6 Conclusion: Python’s Role in Reservoir Engineering In this section, we’ve explored the multifaceted reasons why Python has become an indispensable tool for reservoir engineers. Its versatility, readability, open-source community, and extensive libraries collectively empower professionals in the oil and gas industry to efficiently address complex engineering challenges. Python provides a unified programming environment that spans data analysis, numerical simulations, data visualization, and machine learning, making it a vital asset in the reservoir engineering toolkit. As we proceed, we’ll delve deeper into the practical applications of Python, leveraging its strengths to tackle real-world reservoir engineering problems. Let’s now venture into the heart of Python’s applications in reservoir engineering and see firsthand how it revolutionizes the field. In summary, Python’s versatility, readability, open-source nature, and extensive libraries make it an excellent choice for reservoir engineers looking to harness the power of programming for their work. 2.7 Getting Started with Python 2.7.1 Introduction Now that we’ve established why Python is an essential tool for reservoir engineers, let’s dive into the practical side of things. In this chapter, we’ll guide you through the process of setting up Python on your system and getting started with your first Python program. Whether you’re new to programming or a seasoned engineer, this section will ensure you have a solid foundation to harness Python’s capabilities effectively. 2.7.2 Installing Python Before you can start coding in Python, you need to install it on your computer. Here’s a step-by-step guide to getting Python up and running: 2.7.3 Choosing a Python Distribution Python comes in various distributions, but for our purposes, we recommend Anaconda. Anaconda is a popular distribution that includes not only Python but also a collection of essential libraries and tools commonly used in scientific and engineering applications. 2.7.4 Downloading Anaconda Visit the Anaconda website (https://www.anaconda.com/products/individual) and download the installer for your operating system (Windows, macOS, or Linux). Follow the installation instructions for your specific operating system. Anaconda provides a user-friendly installer that guides you through the process. 2.7.5 Verifying the Installation After installing Anaconda, you can verify that Python is installed correctly by opening a command prompt or terminal window and entering the following command: $python --version If you have Python 3 installed, and it is your default version you should see something like this: $ python --version Python 3.6.0 2.8 Setting Up Your Python Environment Virtual environments are essential for managing project-specific dependencies and isolating them from your system’s Python installation. We recommend using them for every reservoir engineering project. Here’s how to create a virtual environment: 2.8.1 Manual Virtual Environment Open your terminal or command prompt. Navigate to your project’s directory using the cd command. Run the following command to create a virtual environment named ‘myenv’ (you can choose a different name): python -m venv myenv Activate the virtual environment: On Windows: myenv\\Scripts\\activate On macOS and Linux: source myenv/bin/activate You’ll notice that your terminal prompt changes, indicating you are now within the virtual environment. 2.8.2 Creating a Virtual Environment with Anaconda Anaconda provides a simple way to create and manage virtual environments using the conda command: Open Anaconda Navigator. Navigate to the ‘Environments’ tab. Click ‘Create’ to create a new environment. Name it and choose Python 3.x as the version. Activate the environment by clicking ‘Play’ (▶) next to its name. Now that you have Python installed and a virtual environment set up, you’re ready to start using Python for reservoir engineering. In the next chapters, we’ll explore the core libraries and their applications in depth. "],["python-basics.html", "3 Python Basics 3.1 Lists 3.2 List comprehensions 3.3 Tuples 3.4 Dictionaries 3.5 Set 3.6 Control Flow and Functions 3.7 Python Libraries for Reservoir Engineering 3.8 Hands-On Practice 3.9 Chapter Summary 3.10 Further Reading", " 3 Python Basics In this chapter, we’ll delve into the foundational aspects of Python programming. Whether you’re entirely new to Python or looking for a refresher, this chapter will provide you with the fundamental building blocks you need to work effectively with Python in the context of reservoir engineering. We’ll cover variables, data types, operators, and the basic syntax of Python, ensuring you have a solid foundation to build upon in the following chapters. Creating variables and assigning values To create a variable in Python, all you need to do is specify the variable name, and then assign a value to it. # Integer a = 2 print(a) # Output: 2 # Floating point pi = 3.14 print(pi) # Output: 3.14 # String c = &#39;A&#39; print(c) # Output: A You can not use python’s keywords as a valid variable name. You can see the list of keyword by: import keyword print(keyword.kwlist) Even though there’s no need to specify a data type when declaring a variable in Python, while allocating the necessary area in memory for the variable, the Python interpreter automatically picks the most suitable built-in type for it: type() function can be used to determine the type of a given variable. a = 2 print(type(a)) # Output: &lt;type &#39;int&#39;&gt; Comments and Documentation Single line, inline and multiline comments Single line comment: # This is a single line comment in Python Inline comment: used in same line as program. # is used to comment print(&quot;Hello World&quot;) # This line prints &quot;Hello World&quot; Multiline comment: &quot;&quot;&quot; This type of comment spans multiple lines. These are mostly used for documentation of functions, classes and modules. &quot;&quot;&quot; Block Indentation Python uses indentation to define control and loop constructs. This contributes to Python’s readability. Python uses the colon symbol (:) and indentation for showing where blocks of code begin and end. That is, blocks in Python, such as functions, loops, if clauses and other constructs, have no ending identifiers. All blocks start with a colon and then contain the indented lines below it. For example: def my_function(): # This is a function definition. Note the colon (:) a = 2 # This line belongs to the function because it&#39;s indented return a # This line also belongs to the same function print(my_function()) # This line is OUTSIDE the function block 3.0.1 Datatypes Built-in Types Booleans bool: A boolean value of either True or False. Logical operations like and, or, not can be performed on booleans. x or y # if x is False then y otherwise x x and y # if x is False then x otherwise y not x # if x is True then False, otherwise True Numbers int: Integer number a = 2 b = 100 float: Floating point number a = 2.0 b = 100.e0 complex: Complex numbers a = 2 + 1j b = 100 + 10j Strings str(&#39;hello&#39;) Sequences and collections tuple : An ordered collection of n values of any type. tuple supports indexing; immutable; hashable if all its members are hashable. list : An ordered collection of n values of any type. list are Not hashable; mutable. set: An unordered collection of unique values. Items must be hashable. dict: An unordered collection of unique key-value pairs; keys must be hashable. An object is hashable if it has a hash value which never changes during its lifetime. and can be compared to other objects. a = (1, 2, 3) # example of tuple. () bracket is used to create tuple b = (&#39;a&#39;, 1, &#39;python&#39;, (1, 2)) # example of tuple, multiple data type allowed b[2] = &#39;something else&#39; # returns a TypeError. This is not allowed a = [1, 2, 3] # example of list. [] bracket is used to create list b = [&#39;a&#39;, 1, &#39;python&#39;, (1, 2), [1, 2]] # example of list, multiple data type allowed b[2] = &#39;something else&#39; # allowed a = {1, 2, &#39;a&#39;} # example of set. {} bracket is used to create set. only unique values allowed a = {1: &#39;one&#39;, 2: &#39;two&#39;} # example of dict. b = {&#39;a&#39;: [1, 2, 3], &#39;b&#39;: &#39;a string&#39;} Collection Types There are a number of collection types in Python. While types such as int and str hold a single value, collection types hold multiple values. 3.1 Lists The list type is probably the most commonly used collection type in Python. Despite its name, a list is more like an array in other languages, mostly JavaScript. In Python, a list is merely an ordered collection of valid Python values. A list can be created by enclosing values, separated by commas, in square brackets: int_list = [1, 2, 3] string_list = [&#39;abc&#39;, &#39;defgh&#39;] # A list can be empty: empty_list = [] The elements of a list are not restricted to a single data type. A list can also contain another list as its element: mixed_list = [1, &#39;abc&#39;, True, 2.34, None] nested_list = [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3]] The elements of a list can be accessed via an index, or numeric representation of their position. Lists in Python are zero-indexed meaning that the first element in the list is at index 0, the second element is at index 1 and so on. Indices can also be negative which means counting from the end of the list (-1 being the index of the last element). names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;] print(names[0]) # Alice print(names[2]) # Craig print(names[-1]) # Eric print(names[-4]) # Bob Lists allow to use slice notation as lst[start:end:step]. The output of the slice notation is a new list containing elements from index start to end-1. If options are omitted start defaults to beginning of list, end to end of list and step to 1: lst = [1, 2, 3, 4] lst[1:] # [2, 3, 4] lst[:3] # [1, 2, 3] lst[::2] # [1, 3] lst[::-1] # [4, 3, 2, 1] lst[-1:0:-1] # [4, 3, 2] lst[5:8] # [] since starting index is greater than length of lst, returns empty list lst[1:10] # [2, 3, 4] since ending index is greater than length of lst, omit ending index lst[3:1:-1] # [4, 3] index(value, [startIndex]) – gets the index of the first occurrence of the input value. If the input value is not in the list a ValueError exception is raised. If a second argument is provided, the search is started at that specified index. a = [1, 2, 3, 4, 5, 6, 7, 7] a.index(7) # Returns: 6 a.index(49) # ValueError, because 49 is not in a. a.index(7, 7) # Returns: 7 a.index(7, 8) # ValueError, because there is no 7 starting at index 8 Lists are mutable, so you can change the values in a list. Besides, it is possible to add and/or remove elements from a list. Append object to end of list with List.append(object). Add a new element to list at a specific index. List.insert(index, object). Remove the first occurrence of a value with List.remove(value) names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;] names[0] = &#39;Ann&#39; print(names) # Outputs [&#39;Ann&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;] names.append(&quot;Sia&quot;) print(names) # Outputs [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;, &#39;Sia&#39;] names.insert(1, &quot;Nikki&quot;) print(names) # Outputs [&#39;Alice&#39;, &#39;Nikki&#39;, &#39;Bob&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;, &#39;Sia&#39;] names.remove(&quot;Bob&quot;) print(names) # Outputs [&#39;Alice&#39;, &#39;Nikki&#39;, &#39;Craig&#39;, &#39;Diana&#39;, &#39;Eric&#39;, &#39;Sia&#39;] Note that the append() method only appends one new element to the end of the list. If you append a list to another list, the list that you append becomes a single element at the end of the first list. # Appending a list to another list a = [1, 2, 3, 4, 5, 6, 7, 7] b = [8, 9] a.append(b) # a: [1, 2, 3, 4, 5, 6, 7, 7, [8, 9]] a[8] # Returns: [8,9] if you want to add all element of one list to other list. you have to extends the list by appending elements from another enumerable. a = [1, 2, 3, 4, 5, 6, 7, 7] b = [8, 9, 10] # Extend list by appending all elements from b a.extend(b) # a: [1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10] # Extend list with elements from a non-list enumerable: a.extend(range(3)) # a: [1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10, 0, 1, 2] Lists can also be concatenated with the + operator. Note that this does not modify any of the original lists rather create a new list. a = [1, 2, 3, 4, 5, 6] + [7, 7] + b # a: [1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10] Common function of list Get the index in the list of the first item whose value is x. name.index(&quot;Alice&quot;) # Output 0 # length of list len(names) # Output 6 count occurrence of any item in list a = [1, 1, 1, 2, 3, 4] a.count(1) 3 # Reverse the list a.reverse() [4, 3, 2, 1, 1, 1] # or a[::-1] [4, 3, 2, 1, 1, 1] pop([index]) – removes and returns the item at index. With no argument it removes and returns the last element of the list. it is important to note that it removes the item from the list. names.pop() # Outputs &#39;Sia sort() – sorts the list in numerical and lexicographical order and returns None. Lists can also be reversed when sorted using the reverse=True flag in the sort() method. a.sort() # a = [1, 2, 3, 4, 5, 6, 7, 8] # Sorts the list in numerical order a.sort(reverse=True) # a = [8, 7, 6, 5, 4, 3, 2, 1] You can iterate over the list elements like below: for element in my_list: print (element) Replication multiplying an existing list by an integer will produce a larger list consisting of that many copies of the original. This can be useful for example for list initialization b = [&quot;blah&quot;] * 3 # b = [&quot;blah&quot;, &quot;blah&quot;, &quot;blah&quot;] b = [1, 3, 5] * 5 # [1, 3, 5, 1, 3, 5, 1, 3, 5, 1, 3, 5, 1, 3, 5] Element deletion it is possible to delete multiple elements in the list using the del keyword and slice notation: a = list(range(10)) del a[::2] # a = [1, 3, 5, 7, 9] del a[-1] # a = [1, 3, 5, 7] del a[:] # a = [] Copying The default assignment “=” assigns a reference of the original list to the new name. That is, the original name and new name are both pointing to the same list object. Changes made through any of them will be reflected in another. This is often not what you intended. a= [1, 2, 3, 4, 5] b = a a.append(6) # b: [1, 2, 3, 4, 5, 6] If you want to create a copy of the list you have below options. You can slice it: new_list = old_list[:] or You can use the built in list() function: new_list = list(old_list) copy() – Returns a shallow copy of the list a= [1, 2, 3, 4, 5] aa = a.copy() # aa = [1, 2, 3, 4, 5] Checking if list is empty The emptiness of a list is associated to the boolean False, so you don’t have to check len(lst) == 0, but just lst or not lst. lst = [] if not lst: print(&quot;list is empty&quot;) list is empty # Output: list is empty Checking whether an item is in a list Python makes it very simple to check whether an item is in a list. Simply use the in operator. lst = [&#39;test&#39;, &#39;tweet&#39;, &#39;troop&#39;, &#39;treat&#39;] &#39;test&#39; in lst True # Out: True &#39;toast&#39; in lst False # Out: False zip returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables: alist = [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;] blist = [&#39;b1&#39;, &#39;b2&#39;, &#39;b3&#39;] for a, b in zip(alist, blist): print(a, b) a1 b1 a2 b2 a3 b3 If the lists have different lengths then the result will include only as many elements as the shortest one: alist = [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;] blist = [&#39;b1&#39;, &#39;b2&#39;, &#39;b3&#39;, &#39;b4&#39;] for a, b in zip(alist, blist): print(a, b) a1 b1 a2 b2 a3 b3 Length of a list Use len() to get the one-dimensional length of a list. len() also works on strings, dictionaries, and other data structures similar to lists. Remove duplicate values in list Removing duplicate values in a list can be done by converting the list to a set (that is an unordered collection of distinct objects). If a list data structure is needed, then the set can be converted back to a list using the function list(). Note that by converting a list to a set the original ordering is lost. 3.2 List comprehensions List comprehensions in Python are concise, syntactic constructs. They can be utilized to generate list from other lists by applying functions to each element in the list. The following section explains and demonstrates the use of these expressions A list comprehension creates a new list by applying an expression to each element of an iterable. The most basic form is: [ &lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; ] There’s also an optional if condition: for example To create a list of squared integers: squares = [x * x for x in (1, 2, 3, 4)] # create a list of characters in apple, replacing non vowels with &#39;*&#39; # When using if/else together use them before the loop [x if x in &#39;aeiou&#39; else &#39;*&#39; for x in &#39;apple&#39;] #[&#39;a&#39;, &#39;*&#39;, &#39;*&#39;, &#39;*&#39;, &#39;e&#39;] Double Iteration Order of double iteration [... for x in ... for y in ...] is either natural or counter-intuitive. The rule of thumb is to follow an equivalent for loop: In-place Mutation and Other Side Effects Before using list comprehension, understand the difference between functions called for their side effects (mutating, or in-place functions) which usually return None, and functions that return an interesting value. Many functions (especially pure functions) simply take an object and return some object. An in-place function modifies the existing object, which is called a side effect. Other examples include input and output operations such as printing. list.sort() sorts a list in-place (meaning that it modifies the original list) and returns the value None. Therefore, it won’t work as expected in a list comprehension: [x.sort() for x in [[2, 1], [4, 3], [0, 1]]] # [None, None, None] sorted() returns a sorted list rather than sorting in-place. [sorted(x) for x in [[2, 1], [4, 3], [0, 1]]] # [[1, 2], [3, 4], [0, 1]] Conditional List Comprehensions [&lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; if &lt;condition&gt;] For each &lt;element&gt; in &lt;iterable&gt;; if &lt;condition&gt; evaluates to True, add &lt;expression&gt; (usually a function of &lt;element&gt;) to the returned list. For example, this can be used to extract only even numbers from a sequence of integers: [x for x in range(10) if x % 2 == 0] # Out: [0, 2, 4, 6, 8] 3.3 Tuples A tuple is similar to a list except that it is fixed-length and immutable. So the values in the tuple cannot be changed nor the values be added to or removed from the tuple. Tuples are commonly used for small collections of values that will not need to change, such as an IP address and port. Tuples are represented with parentheses instead of square brackets. The same indexing rules for lists also apply to tuples. Tuples can also be nested and the values can be any valid Python. A tuple with only one member must be defined (note the comma) this way: one_member_tuple = (&#39;Only member&#39;,) One of the main differences between lists and tuples in Python is that tuples are immutable, that is, one cannot add or modify items once the tuple is initialized. tuples don’t have .append and .extend methods as list does. You can use the += operator to “append” to a tuple - this works by creating a new tuple with the new element you “appended” and assign it to its current variable; the old tuple is not changed, but replaced! Note that a one-value tuple is also a tuple. To tell Python that a variable is a tuple and not a single value you can use. The symbol _ can be used as a disposable variable name if one only needs some elements of a tuple, acting as a placeholder: a = 1, 2, 3, 4 _, x, y, _ = a # x == 2 # y == 3 3.4 Dictionaries A dictionary in Python is a collection of key-value pairs. The dictionary is surrounded by curly braces. Each pair is separated by a comma and the key and value are separated by a colon. Here is an example: capitals = { &#39;India&#39;: &#39;Delhi&#39;, &#39;Pak&#39;: &#39;Islamabad&#39;, &#39;Nepal&#39;: &#39;Katmandu&#39;, } # To get a value, refer to it by its key: India_capital = capitals[&#39;India&#39;] You can also get all of the keys in a dictionary and then iterate over them: for k in capitals.keys(): print(&#39;{} is the capital of {}&#39;.format(capitals[k], k)) 3.5 Set A set is a collection of elements with no repeats and without insertion order but sorted order. They are used in situations where it is only important that some things are grouped together, and not what order they were included. For large groups of data, it is much faster to check whether or not an element is in a set than it is to do the same for a list. Defining a set is very similar to defining a dictionary: first_names = {&#39;Adam&#39;, &#39;Beth&#39;, &#39;Charlie&#39;} # Or you can build a set using an existing list my_list = [1,2,3] my_set = set(my_list) # iteration on set for name in first_names: print(name) # check if element is there in set if name in first_names: print(name) Installing Python and managing packages with pip. Your first Python program: “Hello, World!” Understanding Python’s dynamic typing and strong typing. Variables, data types (integers, floats, strings), and basic data structures (lists, dictionaries). Python’s syntax and indentation rules. 3.6 Control Flow and Functions Conditional statements (if, else, elif) for decision-making in code. Looping structures (for, while) for iterative tasks. Writing and using functions in Python. Scope of variables and function parameters. 3.7 Python Libraries for Reservoir Engineering Overview of key libraries: NumPy, Pandas, Matplotlib, and SciPy. How these libraries enhance Python’s capabilities for reservoir engineering tasks. Brief introduction to other relevant libraries (scikit-learn, TensorFlow, etc.). 3.8 Hands-On Practice Interactive exercises to apply basic Python concepts. Writing Python code to perform simple reservoir engineering calculations. Getting comfortable with Python’s interactive nature and error handling. 3.9 Chapter Summary Recap of key points covered in the chapter. The importance of mastering Python fundamentals before diving into reservoir engineering applications. 3.10 Further Reading Suggested resources and references for learning more about Python programming. Encouragement to explore and practice Python basics before proceeding to the next chapters. "],["simple-mathematics.html", "4 Simple Mathematics 4.1 Comparisons 4.2 Conditionals 4.3 if, elif, and else 4.4 Boolean Operators 4.5 Loops 4.6 For loops 4.7 While Loop", " 4 Simple Mathematics Addition a, b = 1, 2 # Using the &quot;+&quot; operator: a + b # = 3 if we add different data types these are the possible combinations (builtin types): int and int (gives an int) int and float (gives a float) int and complex (gives a complex) float and float (gives a float) float and complex (gives a complex) complex and complex (gives a complex) Note: the + operator is also used for concatenating strings, lists and tuples: &quot;first string &quot; + &quot;second string&quot; # = &#39;first string second string&#39; [1, 2, 3] + [4, 5, 6] # = [1, 2, 3, 4, 5, 6] Subtraction a, b = 1, 2 # Using the &quot;-&quot; operator: b - a # = 1 if we subtract different data types these are the possible combinations (builtin types): int and int (gives an int) int and float (gives a float) int and complex (gives a complex) float and float (gives a float) float and complex (gives a complex) complex and complex (gives a complex) Multiplication a, b = 2, 3 var = a * b # = 6 Division a, b = 2, 3 var = b / a # = 1.5 int and int (gives an int in Python 2 and a float in Python 3) int and float (gives a float) int and complex (gives a complex) float and float (gives a float) float and complex (gives a complex) complex and complex (gives a complex) Exponentiation a, b = 2, 3 a ** b # = 8 Modulus Like in many other languages, Python uses the % operator for calculating modulus. 3 % 4 # 3 10 % 2 # 0 6 % 4 # 2 4.1 Comparisons Comparison by is vs == a == b compares the value of a and b. it returns true if values of a is equal to b. a is b will compare the identities of a and b. Basically, is can be thought of as shorthand for id(a) == id(b). lets understand this with an example. a = &#39;Python is fun!&#39; b = &#39;Python is fun!&#39; a == b # returns True a is b # returns False a = [1, 2, 3, 4, 5] b = a # b references a a == b # True a is b # True b = a[:] # b now references a copy of a a == b # True a is b # False Greater than or less than x &gt; y x &lt; y These operators compare two types of values, they’re the less than and greater than operators. For numbers this simply compares the numerical values to see which is larger. For strings they will compare lexicographically, which is similar to alphabetical order but not quite the same 12 &gt; 4 # True 12 &lt; 4 # False 1 &lt; 4 # True &quot;alpha&quot; &lt; &quot;beta&quot; # True &quot;gamma&quot; &gt; &quot;beta&quot; # True &quot;gamma&quot; &lt; &quot;OMEGA&quot; # False Not equal to x != y This returns True if x and y are not equal and otherwise returns False. 12 != 1 # True 12 != &#39;12&#39; # True &#39;12&#39; != &#39;12&#39; # False 4.2 Conditionals Conditional expressions, involving keywords such as if, elif, and else, provide Python programs with the ability to perform different actions depending on a boolean condition: True or False. This section covers the use of Python conditionals, boolean logic, and ternary statements. 4.3 if, elif, and else In Python you can define a series of conditionals using if for the first one, elif for the rest, up until the final (optional) else for anything not caught by the other conditionals. number = 5 if number &gt; 2: print(&quot;Number is bigger than 2.&quot;) elif number &lt; 2: # Optional clause (you can have multiple elifs) print(&quot;Number is smaller than 2.&quot;) else: # Optional clause (you can only have one else) print(&quot;Number is 2.&quot;) Number is bigger than 2. Using else if instead of elif will trigger a syntax error and is not allowed. 4.4 Boolean Operators and check the and condition. return True if both the conditions are true. x = True y = True z = x and y # z = True x = True y = False z = x and y # z = False x = False y = True z = x and y # z = False x = False y = False z = x and y # z = False or Return True if any of the conditions is true. x = True y = True z = x or y # z = True x = True y = False z = x or y # z = True x = False y = True z = x or y # z = True x = False y = False z = x or y # z = False not It returns the opposite of the statement. x = True y = not x # y = False x = False y = not x # y = True Testing for multiple conditions A common mistake when checking for multiple conditions is to apply the logic incorrectly. Each variable needs to be compared separately. a=1 b=6 if a &gt; 2 and b &gt; 2: print(&#39;yes&#39;) else: print(&#39;no&#39;) no if a == 3 or a == 4 or a == 6: # checking or condition print(&#39;yes&#39;) else: print(&#39;no&#39;) no 4.5 Loops 4.6 For loops for loops iterate over a collection of items, such as list or dict, and run a block of code with each element from the collection. for i in [0, 1, 2, 3, 4]: print(i) The above for loop iterates over a list of numbers and print each item. range is a function that returns a series of numbers under an iterable form, thus it can be used in for loops: for i in range(5): print(i) # Returns 0 1 2 3 4 Note that 5 is not printed as the range here is the first five numbers counting from 0. In range function we can also give starting and ending number. for example for x in range(1, 6): print(x) # Returns 1 2 3 4 5 Iterating over lists To iterate through a list you can use for: for x in [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]: print(x) # This will print out the elements of the list: one two three four If you want to loop though elements of a list and have an index for the elements as well, you can use Python’s enumerate function: for index, item in enumerate([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]): print(index, &#39;:&#39;, item) 0 : one 1 : two 2 : three 3 : four enumerate will generate tuples, which are unpacked into index (an integer) and item (the actual value from the list). The above loop will print. The Pass Statement pass is a null statement for when a statement is required by Python syntax (such as within the body of a for or while loop), but no action is required or desired by the programmer. for x in range(10): pass #we don&#39;t want to do anything, or are not ready to do anything here, so we&#39;ll pass In this example, nothing will happen. The for loop will complete without error, but no commands or code will be executed. pass allows us to run our code successfully without having all commands and action fully implemented Iterating over dictionaries To iterate through keys of a dictionary, you can use: d = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3} for key in d: print(key) This is equivalent to: for key in d.keys(): print(key) To iterate through its values, use: for value in d.values(): print(value) To iterate through its keys and values, use: for key, value in d.items(): print(key, &quot;::&quot;, value) Looping and Unpacking If you want to loop over a list of tuples for example: collection = [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;), (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;)] # we can unbox the items like for i1, i2, i3 in collection: print(f&#39;{i1} : {i2} : {i3}&#39;) Iterating different portion of a list with different step size Suppose you have a long list of elements and you are only interested in every other element of the list. Perhaps you only want to examine the first or last elements, or a specific range of entries in your list. Python has strong indexing built-in capabilities. Here are some examples of how to achieve these scenarios lst = [&#39;alpha&#39;, &#39;bravo&#39;, &#39;charlie&#39;, &#39;delta&#39;, &#39;echo&#39;] for s in lst: print (s[:1]) # print the first letter for idx, s in enumerate(lst): print(&quot;%s has an index of %d&quot; % (s, idx)) for i in range(2,4): print(&quot;lst at %d contains %s&quot; % (i, lst[i])) for s in lst[1::2]: print(s) 4.7 While Loop A while loop will cause the loop statements to be executed until the loop condition is false. The following code will execute the loop statements a total of 4 times. i = 0 while i &lt; 4: #loop statements i = i + 1 4.7.1 break statement When a break statement executes inside a loop, control flow “breaks” out of the loop immediately: i = 0 while i &lt; 7: print(i) if i == 4: print(&quot;Breaking from loop&quot;) break i += 1 The loop conditional will not be evaluated after the break statement is executed. Note that break statements are only allowed inside loops. A break statement inside a function cannot be used to terminate loops that called that function. break statements can also be used inside for loops. for i in (0, 1, 2, 3, 4): print(i) if i == 2: break 4.7.2 continue statement A continue statement will skip to the next iteration of the loop bypassing the rest of the current block but continuing the loop. As with break, continue can only appear inside loops. for i in (0, 1, 2, 3, 4, 5): if i == 2 or i == 4: continue print(i) Note that 2 and 4 aren’t printed, this is because continue goes to the next iteration instead of continuing on to print(i) when i == 2 or i == 4. Nested Loops break and continue only operate on a single level of loop. The following example will only break out of the inner for loop, not the outer while loop. while True: for i in range(1,5): if i == 2: break # Will only break out of the inner loop! Python doesn’t have the ability to break out of multiple levels of loop at once. if this behavior is desired, refactoring one or more loops into a function and replacing break with return may be the way to go. "],["built-in-modules-and-functions.html", "5 Built in Modules and Functions 5.1 Creating a module 5.2 Installing external modules using pip 5.3 Functions 5.4 Lambda function", " 5 Built in Modules and Functions A module is a file containing Python definitions and statements. Function is a piece of code which execute some logic. To check the built in function in python we can use dir(). dir(__builtins__) # returns list of all the builtin modules and function available in python import math dir(math) # return all the function available in math package To know the functionality of any function, we can use built in function help(). 5.1 Creating a module A module is an importable file containing definitions and statements. A module can be created by creating a .py file. # create a file and name it hello.py def say_hello(): print(&quot;Hello!&quot;) Functions in a module can be used by importing the module. For modules that you have made, they will need to be in the same directory as the file that you are importing them into. Modules can be imported by other modules. ```python, eval = FALSE # in another file greet.py import hello hello.say_hello() Specific functions of a module can be imported ``` python # greet.py from hello import say_hello say_hello() Modules can be aliased. we can give an alias to the module if required. as keyword is used to alias a module. # greet.py import hello as ai ai.say_hello() 5.2 Installing external modules using pip pip is your friend when you need to install any package from the plethora of choices available at the python package index. pip is already installed if you’re using Python 2 &gt;= 2.7.9 or Python 3 &gt;= 3.4. Finding a package $ pip search &lt;query&gt; # Searches for packages whose name or summary contains &lt;query&gt; Installing a package is as simple as typing in a terminal / command-prompt. $ pip install [package_name] # latest version of the package $ pip install [package_name]==x.x.x # specific version of the package $ pip install &#39;[package_name]&gt;=x.x.x&#39; # minimum version of the package # where x.x.x is the version number of the package you want to install Upgrading installed packages To get an overview of which of your installed packages have become outdated, run $ pip list --outdated # To upgrade a specific package use $ pip install [package_name] --upgrade 5.3 Functions Functions in Python provide organized, reusable and modular code to perform a set of specific actions. Functions simplify the coding process, prevent redundant logic, and make the code easier to follow. This section describes the declaration and utilization of functions in Python. Python has many built-in functions like print(), input(), len(). Besides built-ins you can also create your own functions to do more specific jobs—these are called user-defined functions. Defining and calling simple functions Using the def statement is the most common way to define a function in python. Here’s an example of a simple function definition which purpose is to print Hello each time it’s called: def greet(): print(&quot;Hello&quot;) #Now let’s call the defined greet() function: greet() Hello That’s another example of a function definition which takes one single argument and displays the passed in value each time the function is called: def greet_two(greeting): print(greeting) #Now let’s call the greet_two() function. Note that we have to give an argument to this function greet_two(&quot;Howdy&quot;) Howdy Also you can give a default value to that function argument: def greet_three(greeting=&quot;Howdy&quot;): print(greeting) #Now you can also call this function without giving argument, in that case it will use default value. greet_three() Howdy greet_three(&quot;Hello&quot;) Hello You’ll notice that unlike many other languages, you do not need to explicitly declare a return type of the function. Python functions can return values of any type via the return keyword. One function can return any number of different types. def many_types(x): if x &lt; 0: return &quot;Hello!&quot; else: return 0 print(many_types(1)) 0 print(many_types(-1)) Hello! As long as this is handled correctly by the caller, this is perfectly valid Python code. Arbitrary number of positional arguments Defining a function capable of taking an arbitrary number of arguments can be done by prefixing one of the arguments with a * def func(*args): # args will be a tuple containing all values that are passed in for i in args: print(i) func(1, 2, 3) # Calling it with 3 arguments 1 2 3 You can’t provide a default for args, for example func(*args=[1, 2, 3]) will raise a syntax error Arbitrary number of keyword arguments You can take an arbitrary number of arguments with a name by defining an argument in the definition with two * in front of it: def func(**kwargs): # kwargs will be a dictionary containing the names as keys and the values as values for name, value in kwargs.items(): print(name, value) func(value1=1, value2=2, value3=3) # Calling it with 3 arguments value1 1 value2 2 value3 3 func() # Calling it without arguments. no output my_dict = {&#39;foo&#39;: 1, &#39;bar&#39;: 2} func(**my_dict) # Calling it with a dictionary foo 1 bar 2 You can’t provide these without names, for example func(1, 2, 3) will raise a TypeError. kwargs is a plain native python dictionary Returning values from functions A function with no return statement implicitly returns None. Similarly a function with a return statement, but no return value or variable returns None. if return is encountered in the function the function will be exited immediately and subsequent operations will not be evaluated: Function unpacking Functions allow you to specify these types of parameters: positional, named, variable positional, Keyword args (kwargs). Here is a clear and concise use of each type. def unpacking(a, b, c=45, d=60, *args, **kwargs): print(a, b, c, d, args, kwargs) unpacking(1,2) 1 2 45 60 () {} unpacking(1,2, 3, 4) 1 2 3 4 () {} unpacking(1,2, c=3, d=4) 1 2 3 4 () {} unpacking(1,2, d=4, c=3) 1 2 3 4 () {} 5.4 Lambda function In Python, lambda functions are a concise way to define small, anonymous functions without the need for a formal def statement. They are often used for simple operations where a full function definition may be unnecessary. Lambda functions are created using the lambda keyword, followed by one or more arguments and an expression. Here’s the basic syntax: lambda arguments: expression For example a lambda function can be written as follows: greet_me = lambda: \"Hello\" Once assigned to a variable, it can be used just like a regular function: print(greet_me()) Lambda functions have several notable characteristics: They are anonymous: Lambda functions do not have a name like regular functions defined with def. They are single-expression functions: Lambda functions can only contain one expression, and the result of that expression is returned as the output. They are often used for short, throwaway functions: Lambda functions are particularly useful in cases where you need a small function for a specific task. Here’s a simple example of a lambda function that squares a number: square = lambda x: x**2 result = square(4) # This will result in &#39;16&#39;. Lambda functions are commonly used in scenarios where you need to pass a function as an argument to another function, such as in sorting and filtering operations with functions like map(), filter(), and sorted(). They can help you write more concise and readable code in such cases. numbers = [1, 2, 3, 4, 5] squared_numbers = list(map(lambda x: x**2, numbers)) # Squares each number in the list. lambdas can take arguments, too: They can also take arbitrary number of arguments / keyword arguments, like normal functions. greeting = lambda x, *args, **kwargs: print(x, args, kwargs) greeting(&#39;hello&#39;, &#39;world&#39;, world=&#39;world&#39;) Lambda functions are a valuable tool when you want to define a simple, one-time-use function without the need for a full function definition. However, for more complex functions or those that require documentation, it’s often better to use regular named functions defined with def. In reservoir engineering, lambda functions can be employed when you need to define quick and simple calculations within your code, providing a concise way to handle specific tasks or transformations of data. This section elaborates on lambda functions in Python, emphasizing their simplicity, single-expression nature, and common use cases in scenarios like data mapping and filtering. It also highlights their potential utility in reservoir engineering for quick and straightforward calculations within your code. "],["introduction-to-numpy.html", "6 Introduction to Numpy 6.1 Why is NumPy Fast? 6.2 N-Dimensional Arrays 6.3 Universal Functions (ufuncs) 6.4 Array Manipulation", " 6 Introduction to Numpy What is NumPy? NumPy, short for “Numerical Python,” is a fundamental library in the Python ecosystem for numerical computing. It provides powerful tools for working with arrays and matrices, making it an indispensable tool in reservoir engineering and scientific computing. In this chapter, we’ll dive deep into NumPy, exploring its core features, array manipulation, and the crucial role it plays in handling reservoir data efficiently. NumPy is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more. NumPy offers several key features that set it apart as the go-to library for numerical computations. At the core of the NumPy package, is the ndarray object. This encapsulates n-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. There are several important differences between NumPy arrays and the standard Python sequences. NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an ndarray will create a new array and delete the original. The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory. The exception: one can have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements. NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Python’s built-in sequences. A growing plethora of scientific and mathematical Python-based packages are using NumPy arrays; though these typically support Python-sequence input, they convert such input to NumPy arrays prior to processing, and they often output NumPy arrays. In other words, in order to efficiently use much (perhaps even most) of today’s scientific/mathematical Python-based software, just knowing how to use Python’s built-in sequence types is insufficient - one also needs to know how to use NumPy arrays. The points about sequence size and speed are particularly important in scientific computing. As a simple example, consider the case of multiplying each element in a 1-D sequence with the corresponding element in another sequence of the same length. For example if the data are stored in two Python lists, a and b, and we want to multiply element of both list we can do it in python like: c = [] for i in range(len(a)): c.append(a[i]*b[i]) This produces the correct answer, but if a and b each contain millions of numbers, we will pay the price for the inefficiencies of looping in Python. We could accomplish the same task much more quickly in C by writing for (i = 0; i &lt; rows; i++): { [i] = a[i]*b[i]; } we know code is C are faster then that are in python. NumPy gives us the best of both worlds: element-by-element operations are the “default mode” when an ndarray is involved, but the element-by-element operation is speedily executed by pre-compiled C code. In NumPy the above multiplication can be achieved by c = a*b The examples above is executed, at near-C speeds, but with the code simplicity we expect from something based on Python. Indeed, the NumPy idiom is even simpler! This last example illustrates two of NumPy’s features which are the basis of much of its power: vectorization and broadcasting. 6.1 Why is NumPy Fast? Vectorization describes the absence of any explicit looping, indexing, etc., in the code - these things are taking place, of course, just “behind the scenes” in optimized, pre-compiled C code. Vectorized code has many advantages, among which are: vectorized code is more concise and easier to read fewer lines of code generally means fewer bugs the code more closely resembles standard mathematical notation (making it easier, typically, to correctly code mathematical constructs) vectorization results in more “Pythonic” code. Without vectorization, our code would be littered with inefficient and difficult to read for loops. 6.2 N-Dimensional Arrays At the heart of NumPy are its N-dimensional arrays, or ndarrays. These are homogeneous data structures that allow you to store and manipulate large datasets efficiently. We’ll cover: Creating ndarrays. Understanding the shape and dimensions of arrays. Accessing and manipulating elements. 6.2.1 Creating ndarrays NumPy’s ndarrays are the cornerstone of numerical computing. They allow you to efficiently store and manipulate data in arrays of various dimensions. Let’s explore how to create ndarrays with examples: Creating ndarrays from Lists You can create ndarrays from Python lists using the np.array() function: import numpy as np # Creating a 1D array from a list arr_1d = np.array([1, 2, 3, 4, 5]) # Creating a 2D array from a list of lists arr_2d = np.array([[1, 2, 3], [4, 5, 6]]) Creating ndarrays with Built-in Functions NumPy provides several functions to create ndarrays with specific properties. Here are a few commonly used functions: import numpy as np # Creating a 1D array of zeros zeros = np.zeros(5) # Creates [0. 0. 0. 0. 0.] # Creating a 2D array of ones ones = np.ones((2, 3)) # Creates a 2x3 array of ones # Creating a range of values range_arr = np.arange(1, 10, 2) # Creates [1 3 5 7 9] # Creating a linearly spaced array linspace_arr = np.linspace(0, 1, 5) # Creates [0. 0.25 0.5 0.75 1. ] Creating ndarrays with Random Data NumPy allows you to generate ndarrays with random data for various applications. Here’s an example using random integers: import numpy as np # Creating a 1D array of random integers random_integers = np.random.randint(1, 100, 5) # Creates an array of 5 random integers between 1 and 100 # Creating a 2D array of random floats random_floats = np.random.rand(3, 4) # Creates a 3x4 array of random floats between 0 and 1 Creating Special ndarrays NumPy offers functions to create special ndarrays, such as identity matrices and empty arrays: import numpy as np # Creating a 3x3 identity matrix identity_matrix = np.eye(3) # Creating an empty 2x2 array (values are uninitialized) empty_array = np.empty((2, 2)) Creating ndarrays is the first step in leveraging NumPy’s capabilities for numerical computing. These examples demonstrate various ways to create ndarrays, from basic ones to those with specific properties, providing you with flexibility in handling data in your reservoir engineering projects. In the next sections, we’ll explore how to manipulate and operate on these ndarrays to perform meaningful data analysis and calculations. 6.2.2 Understanding the Shape and Dimensions of Arrays NumPy arrays come in various shapes and dimensions, and understanding these attributes is essential for effective data analysis and manipulation. Let’s explore how to determine the shape and dimensions of arrays: 6.2.2.1 Shape of Arrays The shape of an array refers to its dimensions, specifying the number of elements along each axis. You can obtain the shape of an ndarray using the .shape attribute: import numpy as np # Creating arrays of different shapes arr_1d = np.array([1, 2, 3, 4, 5]) arr_2d = np.array([[1, 2, 3], [4, 5, 6]]) arr_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) # Getting the shape of arrays shape_1d = arr_1d.shape # Returns (5,), indicating a 1D array with 5 elements shape_2d = arr_2d.shape # Returns (2, 3), indicating a 2D array with 2 rows and 3 columns shape_3d = arr_3d.shape # Returns (2, 2, 2), indicating a 3D array with dimensions 2x2x2 6.2.2.2 Dimensions of Arrays The dimensions of an array represent how many axes it has. You can find the number of dimensions using the .ndim attribute: import numpy as np # Creating arrays of different dimensions arr_1d = np.array([1, 2, 3, 4, 5]) arr_2d = np.array([[1, 2, 3], [4, 5, 6]]) arr_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) # Getting the number of dimensions dim_1d = arr_1d.ndim # Returns 1, indicating a 1D array dim_2d = arr_2d.ndim # Returns 2, indicating a 2D array dim_3d = arr_3d.ndim # Returns 3, indicating a 3D array Understanding the shape and dimensions of arrays is crucial when working with data in reservoir engineering. It helps you ascertain the structure of your data, allowing you to perform operations and computations effectively. In the following chapters, we’ll use this knowledge to analyze and manipulate reservoir data using NumPy. 6.2.3 Manipulating and Operating on ndarrays Now that you’ve learned how to create ndarrays, shape and dimensions of arrays, Accessing and manipulating elements within ndarrays is a fundamental skill in NumPy. Let’s explore various techniques for working with ndarray elements. NumPy provides a wide array of functions and techniques for efficient data manipulation and computation. 6.2.3.1 Accessing Individual Elements You can access individual elements within an ndarray using indexing. Remember that indexing in NumPy is zero-based, so the first element is at index 0: import numpy as np # Creating an ndarray arr = np.array([1, 2, 3, 4, 5]) # Accessing the first element (index 0) first_element = arr[0] # Result: 1 # Accessing the fourth element (index 3) fourth_element = arr[3] # Result: 4 6.2.3.2 Modifying Elements You can modify individual elements in an ndarray using indexing and assignment: import numpy as np # Creating an ndarray arr = np.array([1, 2, 3, 4, 5]) # Modifying the third element (index 2) arr[2] = 10 # The array is now: [1, 2, 10, 4, 5] 6.2.3.3 Slicing for Subsets Slicing allows you to extract subsets of elements from an ndarray using the start:stop:step notation. It’s particularly useful when working with large datasets: import numpy as np # Creating an ndarray arr = np.array([1, 2, 3, 4, 5]) # Slicing to get the first three elements subset = arr[:3] # Result: [1, 2, 3] # Slicing to get even-indexed elements even_elements = arr[::2] # Result: [1, 3, 5] 6.2.3.3.1 Conditional Indexing You can use conditional statements to select elements based on specific conditions: import numpy as np # Creating a 1D array arr = np.array([10, 20, 30, 40, 50]) # Conditional indexing greater_than_30 = arr[arr &gt; 30] # Retrieves elements greater than 30: [40 50] 6.2.3.3.2 Indexing in Multidimensional Arrays For multidimensional arrays, you can use multiple indices to access elements in specific rows and columns: import numpy as np # Creating a 2D array arr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Accessing individual elements element = arr_2d[1, 2] # Retrieves element at row 1, column 2: 6 6.2.3.4 Element-Wise Operations One of the strengths of NumPy is its ability to perform element-wise operations on ndarrays. These operations apply to each element in the array individually, making it efficient for mathematical computations: import numpy as np # Creating two arrays arr1 = np.array([1, 2, 3]) arr2 = np.array([4, 5, 6]) # Addition result_add = arr1 + arr2 # [5 7 9] # Subtraction result_sub = arr1 - arr2 # [-3 -3 -3] # Multiplication result_mul = arr1 * arr2 # [4 10 18] # Division result_div = arr2 / arr1 # [4. 2.5 2.] 6.2.3.5 Broadcasting NumPy’s broadcasting allows you to perform operations on arrays with different shapes, making your code more flexible: import numpy as np # Creating a 2D array arr_2d = np.array([[1, 2, 3], [4, 5, 6]]) # Adding a scalar to the entire array result_broadcast = arr_2d + 10 # [[11 12 13] [14 15 16]] 6.2.3.6 Aggregation Functions NumPy provides aggregation functions that allow you to compute summary statistics on arrays: import numpy as np # Creating an array data = np.array([1, 2, 3, 4, 5]) # Mean mean = np.mean(data) # Calculates the mean: 3.0 # Sum total = np.sum(data) # Calculates the sum: 15 # Maximum max_value = np.max(data) # Finds the maximum value: 5 # Minimum min_value = np.min(data) # Finds the minimum value: 1 6.2.3.7 Indexing and Slicing You can access specific elements or subsets of ndarrays using indexing and slicing: import numpy as np # Creating an array arr = np.array([1, 2, 3, 4, 5]) # Indexing to access a specific element element = arr[2] # Retrieves the third element: 3 # Slicing to get a subset of elements subset = arr[1:4] # Retrieves elements from index 1 to 3: [2 3 4] NumPy’s powerful array operations and manipulation techniques allow you to efficiently analyze, transform, and compute data, making it an invaluable tool for reservoir engineers. In the upcoming chapters, we’ll explore real-world applications of these techniques in the context of reservoir engineering. 6.3 Universal Functions (ufuncs) Universal Functions, commonly referred to as “ufuncs,” are a core feature of NumPy that enable element-wise operations on arrays. These functions efficiently apply operations to each element in an array, making complex computations streamlined. Let’s delve into ufuncs: 6.3.1 Basic Arithmetic Operations NumPy’s ufuncs support basic arithmetic operations: import numpy as np # Creating arrays arr1 = np.array([1, 2, 3]) arr2 = np.array([4, 5, 6]) # Addition result_add = np.add(arr1, arr2) # [5 7 9] # Subtraction result_sub = np.subtract(arr1, arr2) # [-3 -3 -3] # Multiplication result_mul = np.multiply(arr1, arr2) # [4 10 18] # Division result_div = np.divide(arr2, arr1) # [4. 2.5 2.] 6.3.2 Mathematical Functions NumPy’s ufuncs provide a wide range of mathematical functions: import numpy as np # Creating an array arr = np.array([1, 2, 3, 4, 5]) # Square root sqrt_result = np.sqrt(arr) # [1. 1.41421356 1.73205081 2. 2.23606798] # Exponential exp_result = np.exp(arr) # [ 2.71828183 7.3890561 20.08553692 54.59815003 148.4131591 ] # Trigonometric functions (sin, cos, tan) sin_result = np.sin(arr) # [ 0.84147098 0.90929743 0.14112001 -0.7568025 -0.95892427] 6.3.3 Aggregation Functions Ufuncs are also used for aggregation functions to calculate summary statistics: import numpy as np # Creating an array data = np.array([1, 2, 3, 4, 5]) # Mean mean = np.mean(data) # Calculates the mean: 3.0 # Sum total = np.sum(data) # Calculates the sum: 15 # Maximum max_value = np.max(data) # Finds the maximum value: 5 # Minimum min_value = np.min(data) # Finds the minimum value: 1 Ufuncs play a pivotal role in efficient data processing, allowing you to perform complex operations across large arrays with ease. In reservoir engineering, they streamline calculations and analyses on reservoir data, enhancing your ability to derive meaningful insights. 6.3.4 Broadcasting for Operations on Arrays of Different Shapes One of the powerful features of ufuncs in NumPy is broadcasting, which allows you to perform operations on arrays with different shapes. Broadcasting automatically adjusts the dimensions of smaller arrays to match those of larger arrays, making element-wise operations possible even when array shapes don’t exactly match: import numpy as np # Creating a 2D array arr_2d = np.array([[1, 2, 3], [4, 5, 6]]) # Adding a scalar to the entire array result_broadcast = arr_2d + 10 # [[11 12 13] [14 15 16]] In this example, NumPy broadcasts the scalar value 10 to match the shape of arr_2d automatically. This makes it effortless to perform operations that involve arrays of different shapes. Broadcasting also extends to operations between arrays of different dimensions: import numpy as np # Creating a 2D array arr_2d = np.array([[1, 2, 3], [4, 5, 6]]) # Creating a 1D array arr_1d = np.array([10, 20, 30]) # Adding the 1D array to each row of the 2D array result_broadcast = arr_2d + arr_1d # [[11 22 33] # [14 25 36]] In this case, NumPy broadcasts the 1D array to match the shape of the 2D array and performs the element-wise addition seamlessly. Broadcasting simplifies your code by eliminating the need to manually reshape arrays or write loops for operations on arrays with different shapes. This feature is especially valuable when working with complex reservoir data where data shapes may vary, allowing you to efficiently perform calculations and data transformations. In the upcoming chapters, we’ll apply broadcasting to real-world reservoir engineering scenarios, demonstrating its practical benefits. 6.4 Array Manipulation Array manipulation in NumPy involves reshaping, concatenating, splitting, indexing, and slicing arrays to transform and rearrange data. These techniques are essential for effective data processing and analysis in reservoir engineering: 6.4.1 Reshaping Arrays You can reshape arrays to change their dimensions, allowing you to adapt data structures to your needs: import numpy as np # Creating a 1D array arr = np.array([1, 2, 3, 4, 5, 6]) # Reshaping to a 2D array (2 rows, 3 columns) reshaped_arr = arr.reshape(2, 3) 6.4.2 Concatenating Arrays Concatenation combines multiple arrays along a specified axis, creating a larger array: import numpy as np # Creating two arrays arr1 = np.array([1, 2, 3]) arr2 = np.array([4, 5, 6]) # Concatenating along the rows (axis=0) concatenated_arr = np.concatenate((arr1, arr2)) # [1 2 3 4 5 6] 6.4.3 Splitting Arrays Splitting divides an array into multiple smaller arrays along a specified axis: import numpy as np # Creating an array arr = np.array([1, 2, 3, 4, 5, 6]) # Splitting into three equal parts split_arr = np.split(arr, 3) # [array([1, 2]), array([3, 4]), array([5, 6])] 6.4.4 Indexing and Slicing You can access specific elements or subsets of arrays using indexing and slicing techniques: import numpy as np # Creating a 2D array arr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Indexing to access specific elements element = arr_2d[1, 2] # Retrieves element at row 1, column 2: 6 # Slicing to extract subsets subset = arr_2d[0:2, 1:3] # Retrieves elements from rows 0 to 1 and columns 1 to 2 Array manipulation techniques are indispensable when working with reservoir data, allowing you to restructure, combine, and extract data efficiently. This section offers a comprehensive introduction to NumPy, covering its key features, array manipulation, and its essential role in reservoir engineering. It sets the stage for the practical applications of NumPy in the following chapters, providing readers with a strong foundation in the library’s capabilities. "],["reservoir-engineering.html", "7 Reservoir Engineering 7.1 Introduction 7.2 Reservoir Characteristics 7.3 Reservoir Rock 7.4 Reservoir Drive Mechanisms 7.5 Reservoir Types 7.6 Reservoir Evaluation 7.7 Chapter Summary", " 7 Reservoir Engineering 7.1 Introduction In this chapter, we’ll delve into the foundational principles of reservoir engineering, providing you with essential knowledge to understand reservoir behavior, properties, and key terminology. Whether you’re new to reservoir engineering or need a refresher, this chapter will lay the groundwork for your journey into the world of hydrocarbon reservoirs. 7.2 Reservoir Characteristics Flow in porous media is a complex phenomenon and cannot be described as explicitly as flow through pipes or conduits. Unlike in pipes, where dimensions and flow capacity can be easily measured, porous media involve irregular flow paths that require experimental and analytical approaches. 7.2.1 Key Characteristics: Types of fluids in the reservoir. Flow regimes. Reservoir geometry. Number of flowing fluids in the reservoir. 7.2.2 Types of Fluids Hydrocarbons within a reservoir can exist in different phases, including gas, oil, and water. The phase behavior and properties of these fluids are critical factors that affect reservoir performance. Phase behavior describes how hydrocarbons behave under varying pressure and temperature conditions. Fluid properties, such as density, viscosity, and compressibility, are fundamental to understanding how fluids flow within the reservoir and how they interact with reservoir rock. Additionally, pressure and temperature gradients within the reservoir have significant implications for fluid behavior. Reservoir engineers must grasp these concepts to predict reservoir performance accurately and optimize production strategies. The objective of this chapter is to present the mathematical relationships designed to describe flow behavior of reservoir fluids. The mathematical forms of these relationships will vary depending upon characteristics of the reservoir. The primary reservoir characteristics that must be considered include: Reservoir fluids are classified into three groups based on the isothermal compressibility coefficient (\\(c\\)): Incompressible Fluids: Volume or density does not change with pressure. \\[ c = 0 \\] Slightly Compressible Fluids: Exhibit small changes in volume or density with pressure: \\[ c = -\\frac{1}{V} \\frac{\\partial V}{\\partial p} = \\frac{1}{\\rho} \\frac{\\partial \\rho}{\\partial p} \\] Simplifying: \\[ V = V_{ref} \\cdot \\exp\\left(c \\cdot (p_{ref} - p)\\right) \\] Compressible Fluids: Experience large changes in volume with pressure: \\[ c_g = \\frac{1}{p} - \\frac{1}{Z} \\frac{\\partial Z}{\\partial p} \\] 7.2.3 Flow Regimes There are three main flow regimes that describe fluid flow and reservoir pressure distribution over time: Steady-State Flow: The pressure at every location in the reservoir remains constant with time. \\[ \\frac{\\partial p}{\\partial t} = 0 \\] Unsteady-State Flow (Transient Flow): The pressure changes with time at any location in the reservoir. \\[ \\frac{\\partial p}{\\partial t} = f(i, t) \\] Pseudosteady-State Flow (Semisteady-State): The pressure declines linearly with time at all points in the reservoir. \\[ \\frac{\\partial p}{\\partial t} = \\text{constant} \\] 7.2.4 Reservoir Geometry The reservoir’s geometry affects flow behavior. Common geometries include: Radial Flow: Fluids flow radially towards or away from a well. Linear Flow: Fluids flow in parallel, straight paths, typically observed near fractures. Spherical and Hemispherical Flow: Occurs near partially penetrating wells or in regions with localized completions. 7.2.5 Number of Flowing Fluids pressure behavior of a reservoir depends upon the number of mobile fluids in the reservoir. There are generally three cases of flowing system: 1. single-phase flow (oil, water, or gas); 2. two-phase flow (oil water, oil gas, or gas water); 3. three-phase flow (oil, water, and gas). 7.3 Reservoir Rock Reservoir rock forms the foundation of hydrocarbon reservoirs and plays a crucial role in fluid storage and movement. Different rock types, such as sandstone and limestone, exhibit varying levels of porosity and permeability, which determine their ability to store and transmit fluids. Porosity refers to the volume of pore space within the rock, while permeability measures the rock’s ability to allow fluids to flow through it. Understanding these properties is essential for reservoir engineers, as they impact reservoir behavior and influence decisions regarding drilling, production strategies, and reservoir management. 7.4 Reservoir Drive Mechanisms Hydrocarbons within a reservoir are typically under pressure, and various mechanisms drive their movement towards production wells. We’ll cover the primary drive mechanisms: 7.4.1 Natural Gas Drive In reservoirs primarily driven by natural gas expansion, the energy released as gas expands drives hydrocarbons towards production wells. This mechanism is common in gas reservoirs and provides a natural means of pushing hydrocarbons to the surface. Understanding how natural gas drive works, including the impact of reservoir pressure and gas properties, is crucial for reservoir engineers when designing production strategies and estimating recovery rates. 7.4.2 Water Drive Water drive is a prevalent mechanism in many reservoirs, especially as hydrocarbons are produced and reservoir pressure decreases. In water drive systems, water influx displaces hydrocarbons towards production wells. Engineers must analyze the behavior of water and hydrocarbons in reservoirs to optimize water flooding operations and manage water production effectively. This understanding is vital for maximizing hydrocarbon recovery in water drive reservoirs. 7.4.3 Other Drive Mechanisms Beyond natural gas and water drives, various other mechanisms, such as gravity drainage and compaction drive, can influence reservoir behavior. These mechanisms may be applicable in specific geological and reservoir conditions. Reservoir engineers need to be aware of these alternative drive mechanisms and their implications for reservoir performance and production strategies. 7.5 Reservoir Types Reservoirs come in various types and configurations, each with its unique characteristics. We’ll explore: 7.5.1 Oil Reservoirs Oil reservoirs primarily contain liquid hydrocarbons. These reservoirs come in various classifications, including conventional and unconventional. Conventional oil reservoirs are typically found in porous rock formations and are easier to produce. Unconventional oil reservoirs, such as shale oil, present unique challenges due to their complex geological characteristics. Reservoir engineers working on oil reservoirs must understand the properties and behavior of oil and design production strategies to optimize recovery. 7.5.2 Gas Reservoirs Gas reservoirs contain primarily gaseous hydrocarbons, such as natural gas. Understanding gas reservoir behavior, including phase behavior and the impact of reservoir pressure and temperature, is essential for efficiently producing gas. Reservoir engineers working with gas reservoirs must consider factors like gas compression and transportation to ensure successful production and delivery to consumers. 7.5.3 Oil and Gas Reservoirs Some reservoirs contain both oil and gas phases, often in varying proportions. These mixed-phase reservoirs require specialized approaches to production and reservoir management. Reservoir engineers need to develop strategies that account for the distinct characteristics of oil and gas within the reservoir to optimize recovery. 7.6 Reservoir Evaluation Reservoir evaluation involves assessing the potential and performance of a reservoir. Reservoir engineers employ various techniques, including well testing, reservoir simulation, and data analysis, to understand reservoir behavior, estimate recoverable reserves, and design production strategies. Well testing provides real-time data on reservoir performance, while reservoir simulation uses mathematical models to predict future behavior. Data analysis involves interpreting historical production data and incorporating it into reservoir models. Accurate reservoir evaluation is crucial for making informed decisions regarding drilling, production, and reservoir management. 7.7 Chapter Summary This chapter provides a comprehensive introduction to the key concepts of reservoir engineering, equipping readers with foundational knowledge that will be essential for their journey into the field of hydrocarbon reservoirs. "],["fundamental-properties-of-gas.html", "8 Fundamental Properties of Gas 8.1 Gas Behavior 8.2 Gas Composition 8.3 Phase Behavior 8.4 Review of Gas Properties", " 8 Fundamental Properties of Gas In this chapter, we will dive into the essential properties of gases and their relevance in reservoir engineering. A solid understanding of gas properties is crucial for analyzing, modeling, and managing gas reservoirs efficiently. From the behavior of gases under varying pressure and temperature conditions to phase transitions and compositional analysis, this chapter will equip you with the knowledge needed to work with gas reservoirs effectively. 8.1 Gas Behavior Understanding the behavior of gases is foundational to reservoir engineering, particularly when dealing with gas reservoirs. At the heart of this understanding lies the Ideal Gas Law, which describes how gases respond to changes in pressure and temperature. We will explore the ideal gas law, its mathematical formulation, and how it simplifies gas behavior analysis. However, real gases deviate from ideal behavior under certain conditions, such as high pressures and low temperatures. In this chapter, we will also delve into real gas behavior, examining the factors responsible for these deviations and their implications for gas reservoir simulations. This chapter delves into the intricacies of natural gas systems as relevant to gas reservoir engineering, focusing primarily on the behavior and properties concerning pressure, volume, and temperature (PVT). Given that gas extracted from subsurface reservoirs undergoes significant pressure and temperature changes before reaching the sales gas line, understanding its PVT behavior and associated properties is crucial. The PVT behavior of natural gas is contingent upon its chemical composition, which can vary considerably from one reservoir to another, leading to diverse production behaviors. Hence, we commence with a concise exploration of natural gas’s chemical makeup. The fluctuating pressures and temperatures inherent in gas production processes can induce complex phase behavior phenomena within natural gas systems. Thus, we provide a qualitative examination of hydrocarbon system phase behavior here. Beyond elucidating general PVT behavior, we also explore methods and techniques for predicting pertinent gas properties essential for reservoir engineering analyses and assessments. While predominantly empirical, these methods have been refined to such an extent that they often serve as viable substitutes for laboratory measurements. Indeed, in many instances, knowledge of the composition alone is adequate for evaluating gas properties. 8.1.1 Ideal Gas Law The Ideal Gas Law, represented by the equation PV = nRT, stands as a fundamental pillar of gas behavior in reservoir engineering. In this equation, P represents pressure, V is volume, n stands for the number of moles of gas, R denotes the gas constant, and T signifies temperature. This simple yet powerful law states that for an ideal gas, the product of pressure and volume is directly proportional to the number of moles and the absolute temperature. Python can be a valuable tool for reservoir engineers to apply this law in real-world scenarios. Let’s use Python to calculate the volume of a given amount of gas at a specific temperature and pressure: # Constants R = 8.314 # Gas constant in J/(mol*K) P = 10.0 # Pressure in atmospheres (atm) n = 2.0 # Moles of gas T = 298.15 # Temperature in Kelvin (K) # Calculate volume using the Ideal Gas Law V = (n * R * T) / P print(f&quot;Volume of the gas: {V} liters&quot;) In this Python code snippet, we use the Ideal Gas Law to determine the volume of a gas sample based on known values of pressure (P), moles (n), gas constant (R), and temperature (T). Understanding and applying this law is essential for reservoir engineers when dealing with gas reservoirs, as it allows them to make critical predictions about gas behavior and reservoir performance. 8.1.2 Real Gas Behavior While the Ideal Gas Law provides a simplified model for gas behavior, real gases exhibit deviations from ideal behavior under specific conditions, typically at high pressures and low temperatures. These deviations occur due to intermolecular forces and the finite size of gas molecules, which are not accounted for in the ideal gas model. The Van der Waals equation is commonly used to describe the behavior of real gases more accurately. In the Van der Waals equation, the pressure (P) and volume (V) of a gas are adjusted by correction terms to account for molecular interactions and finite molecular size. This equation takes the form: The Van der Waals equation describes the behavior of real gases and incorporates corrections to account for molecular interactions and finite molecular size. It takes the form: \\[ (P + a \\frac{n^2}{V^2})(V - nb) = nRT \\] Where: \\(P\\) is the pressure of the gas. \\(V\\) is the volume of the gas. \\(n\\) is the number of moles of the gas. \\(R\\) is the gas constant. \\(T\\) is the absolute temperature of the gas. \\(a\\) and \\(b\\) are Van der Waals constants specific to each gas. This equation provides a more accurate representation of gas behavior, particularly at high pressures and low temperatures, compared to the ideal gas law. Reservoir engineers use the Van der Waals equation when dealing with gases that exhibit significant deviations from ideal behavior, ensuring more precise predictions in gas reservoir simulations. Python code to calculate the behavior of real gases using the Van der Waals equation is given below. Let’s calculate the corrected pressure and volume for a real gas sample: # Constants for a hypothetical gas (values for illustration) a = 0.0321 # Van der Waals constant &#39;a&#39; in (L^2*atm)/(mol^2) b = 0.0237 # Van der Waals constant &#39;b&#39; in L/mol # Given values P = 15.0 # Pressure in atmospheres (atm) n = 2.0 # Moles of gas T = 273.15 # Temperature in Kelvin (K) # Calculate corrected pressure and volume using the Van der Waals equation corrected_P = (n * R * T) / (n - n * b) - a * (n**2 / ((n - n * b)**2)) corrected_V = (n * R * T) / (corrected_P) print(f&quot;Corrected Pressure: {corrected_P} atm&quot;) print(f&quot;Corrected Volume: {corrected_V} liters&quot;) 8.2 Gas Composition Natural gas primarily consists of volatile paraffins, mainly methane, along with non-hydrocarbon gases like nitrogen, carbon dioxide, and hydrogen sulfide. Traces of helium, argon, and neon may also be present. Water vapor saturates natural gas due to its presence in hydrocarbon-bearing formations. Typically, natural gas composition is expressed in mole fractions or percentages, serving as a proxy for volume fractions. Hydrocarbon components up to heptanes are individually listed, while heavier hydrocarbons are grouped in the heptanes plus fraction. This standard representation suffices for reservoir engineering purposes. 8.3 Phase Behavior Gas reservoirs often contain multiple components, leading to complex phase behavior. Understanding how these components behave under different pressure and temperature conditions is essential for accurately predicting gas reservoir performance. Two key aspects of phase behavior in gas reservoir engineering are phase diagrams and critical points. 8.3.1 Phase Diagrams Phase diagrams provide valuable insights into how gas components behave under varying conditions. These diagrams typically display pressure-temperature (P-T) relationships and help visualize the regions where gases exist in different phases, such as gas, liquid, or solid. These diagrams are essential in understanding how a substance behaves under different conditions, especially in thermodynamics and materials science. Phase Diagram for mixture of gases a phase diagram for a mixture of gases can be significantly more complex than for a single-component system like water vapor. Phase diagrams for gas mixtures involve multiple components and typically require the use of phase equilibrium calculations based on thermodynamic models. The phase behavior of gas mixtures depends on factors such as composition, temperature, and pressure. A common approach to create phase diagrams for gas mixtures is to use phase equilibrium software or simulation tools specifically designed for this purpose. These tools employ equations of state (EOS), such as the Peng-Robinson or Soave-Redlich-Kwong EOS, to model the phase behavior of gas mixtures. Here is a simplified representation of the phase diagram for a binary gas mixture (e.g., methane and ethane) using the Peng-Robinson EOS. Note that this is just a basic illustration and does not provide actual phase equilibrium calculations: import numpy as np import matplotlib.pyplot as plt # Constants for the Peng-Robinson EOS parameters (for illustration purposes) a_mix = 0.85 # Attraction parameter for the mixture b_mix = 0.05 # Co-volume parameter for the mixture Tc_methane = 190.6 # Critical temperature for methane (K) Tc_ethane = 305.3 # Critical temperature for ethane (K) Pc_methane = 45.99 # Critical pressure for methane (bar) Pc_ethane = 48.72 # Critical pressure for ethane (bar) R = 0.083144598 # Universal Gas Constant # Define temperature and pressure ranges T_range = np.linspace(50, 150, 10) # Temperature range (K) P_range = np.linspace(2000, 3000, 100) # Pressure range (bar) # Create a grid of pressure and temperature values P, T = np.meshgrid(P_range, T_range) # Calculate fugacity coefficients for methane and ethane (for illustration) # Note: Actual calculations would involve solving phase equilibrium equations fugacity_methane = np.exp((P - Pc_methane) / (R * T) - b_mix / (R * T) * (P / Pc_methane)) &lt;string&gt;:4: RuntimeWarning: overflow encountered in exp fugacity_ethane = np.exp((P - Pc_ethane) / (R * T) - b_mix / (R * T) * (P / Pc_ethane)) # Create the phase diagram plot plt.figure(figsize=(8, 6)) &lt;Figure size 800x600 with 0 Axes&gt; plt.contourf(P, T, fugacity_methane, levels=20, cmap=&#39;coolwarm&#39;, alpha=0.5) &lt;matplotlib.contour.QuadContourSet object at 0x128d4c820&gt; plt.contourf(P, T, fugacity_ethane, levels=20, cmap=&#39;coolwarm&#39;, alpha=0.5) /Users/anitakumari/azad/coding/Python/venv/lib/python3.9/site-packages/matplotlib/contour.py:1222: RuntimeWarning: overflow encountered in add self.layers = 0.5 * (self._levels[:-1] + self._levels[1:]) &lt;matplotlib.contour.QuadContourSet object at 0x128e5f640&gt; plt.colorbar(label=&#39;Fugacity Coefficient&#39;) &lt;matplotlib.colorbar.Colorbar object at 0x128e3ad00&gt; plt.xlabel(&#39;Pressure (bar)&#39;) Text(0.5, 0, &#39;Pressure (bar)&#39;) plt.ylabel(&#39;Temperature (K)&#39;) Text(0, 0.5, &#39;Temperature (K)&#39;) plt.title(&#39;Phase Diagram for Binary Gas Mixture (Simplified)&#39;) Text(0.5, 1.0, &#39;Phase Diagram for Binary Gas Mixture (Simplified)&#39;) plt.xlim(2000, 3000) (2000.0, 3000.0) plt.ylim(50, 150) (50.0, 150.0) plt.grid(True) plt.show() Phase diagrams are crucial tools for reservoir engineers as they enable the prediction of phase transitions and phase equilibria within the reservoir. In a phase diagram, the critical point stands out as a critical temperature (Tc) and critical pressure (Pc) where a phase transition occurs. The phase diagram allows engineers to assess how far the actual reservoir conditions are from the critical point, influencing decisions regarding production strategies and well operations. 8.3.1.1 Critical Point and Phase Transitions The critical point (also known as the critical state) is a specific condition at which a substance undergoes a phase transition. At the critical point, the distinction between the liquid and gas phases disappears, and the substance becomes a supercritical fluid. This transition has significant implications for reservoir engineers because it affects how gases behave at extreme reservoir conditions. The critical point is characterized by the critical temperature (Tc) and critical pressure (Pc), which are unique to each gas component. These critical properties vary depending on the type of gas present in the reservoir. Understanding the critical point and its proximity to reservoir conditions is essential for predicting phase transitions and ensuring accurate reservoir simulations. 8.3.1.2 different correlation to calculate critical temperature (Tc) and critical pressure (Pc) Here are five different correlations along with Python code chunks to calculate critical temperature (Tc) and critical pressure (Pc). Each correlation provides an estimation of these critical properties based on different parameters. Please note that these correlations provide approximate values and may have varying degrees of accuracy depending on the specific gas mixture and conditions. 8.3.1.2.1 Lee-Kesler Equation The Lee-Kesler equation is a common method to estimate critical temperature (Tc) and critical pressure (Pc) for pure gases. This equation requires knowledge of the acentric factor (ω) and the gas’s reduced temperature (Tr). The Lee-Kesler equation for critical temperature (Tc) is: \\[ Tc = Tc_r \\cdot Tc_{RK} \\] And for critical pressure (Pc): \\[ Pc = Pc_r \\cdot Pc_{RK} \\] Where \\(Tc_r\\) and \\(Pc_r\\) are the critical properties from the Redlich-Kwong equation of state, and \\(Tc_{RK}\\) and \\(Pc_{RK}\\) are constants derived from the acentric factor (ω). Here’s Python code to calculate Tc and Pc using the Lee-Kesler equation: # Constants for Lee-Kesler equation Tc_rk = 190.56 # Critical temperature from Redlich-Kwong (RK) EOS Pc_rk = 45.99 # Critical pressure from Redlich-Kwong (RK) EOS omega = 0.011 # Acentric factor # Calculate Tc and Pc using Lee-Kesler equation Tc = Tc_rk * (1 + omega) # Critical temperature Pc = Pc_rk / (1 + omega) # Critical pressure print(f&quot;Estimated Critical Temperature (Tc): {Tc} K&quot;) print(f&quot;Estimated Critical Pressure (Pc): {Pc} atm&quot;) 8.3.1.3 Beattie-Bridgeman Equation The Beattie-Bridgeman equation provides an estimation of critical temperature (Tc) and critical pressure (Pc) for pure gases based on the triple point temperature (Tt) and the gas’s molecular weight (M). The Beattie-Bridgeman equation for critical temperature (Tc) is: \\[ Tc = 3.2 \\cdot Tt + 11.5 \\cdot M \\] And for critical pressure (Pc): \\[ Pc = 42.5 \\cdot \\frac{M^2}{Vc} \\] Where \\(Vc\\) is the critical volume, which can be estimated as \\(Vc = 10 \\cdot M\\). Here’s Python code to calculate Tc and Pc using the Beattie-Bridgeman equation: # Constants for Beattie-Bridgeman equation Tt = 273.16 # Triple point temperature in K M = 28.97 # Molecular weight of nitrogen (for example) # Calculate critical volume (Vc) Vc = 10 * M # Calculate Tc and Pc using Beattie-Bridgeman equation Tc = 3.2 * Tt + 11.5 * M # Critical temperature Pc = 42.5 * (M ** 2) / Vc # Critical pressure print(f&quot;Estimated Critical Temperature (Tc): {Tc} K&quot;) print(f&quot;Estimated Critical Pressure (Pc): {Pc} atm&quot;) This code estimates Tc and Pc using the Beattie-Bridgeman equation based on the provided triple point temperature (Tt) and molecular weight (M). 8.3.1.4 Riedel Equation The Riedel equation offers an estimation of critical temperature (Tc) and critical pressure (Pc) for pure gases using the gas’s boiling point (Tb) and the critical temperature of methane (Tc_CH4). The Riedel equation for critical temperature (Tc) is: \\[ Tc = Tc_{CH4} + 27.9 \\cdot (Tb - Tc_{CH4}) \\] And for critical pressure (Pc): \\[ Pc = 10.6 \\cdot \\left(1 - \\frac{Tc}{Tb}\\right) \\] Where \\(Tc_{CH4}\\) is the critical temperature of methane (Tc_CH4 = 190.6 K). Here’s Python code to calculate Tc and Pc using the Riedel equation: # Constants for Riedel equation Tb = 77.36 # Boiling point of nitrogen (for example) in K Tc_CH4 = 190.6 # Critical temperature of methane in K # Calculate Tc and Pc using Riedel equation Tc = Tc_CH4 + 27.9 * (Tb - Tc_CH4) # Critical temperature Pc = 10.6 * (1 - Tc / Tb) # Critical pressure print(f&quot;Estimated Critical Temperature (Tc): {Tc} K&quot;) print(f&quot;Estimated Critical Pressure (Pc): {Pc} atm&quot;) 8.3.1.5 Yaws’ Equation Yaws’ equation offers a straightforward approach to estimate critical temperature (Tc) and critical pressure (Pc) for hydrocarbon gases using the gas’s molecular weight (M) and the number of carbon atoms (C). The Yaws’ equation for critical temperature (Tc) is: \\[ Tc = 169 + 0.684 \\cdot M + 0.0007 \\cdot M^2 \\] And for critical pressure (Pc): \\[ Pc = 708 - 3.6 \\cdot C \\] Here’s Python code to calculate Tc and Pc using Yaws’ equation: # Constants for Yaws&#39; equation M = 16.04 # Molecular weight of methane (for example) C = 1 # Number of carbon atoms in methane # Calculate Tc and Pc using Yaws&#39; equation Tc = 169 + 0.684 * M + 0.0007 * M**2 # Critical temperature Pc = 708 - 3.6 * C # Critical pressure print(f&quot;Estimated Critical Temperature (Tc): {Tc} K&quot;) print(f&quot;Estimated Critical Pressure (Pc): {Pc} atm&quot;) 8.3.1.6 Pitzer Equation The Pitzer equation provides an estimation of critical temperature (Tc) and critical pressure (Pc) for gases using the critical temperature of methane (Tc_CH4) and the molecular weight (M). The Pitzer equation for critical temperature (Tc) is: \\[ Tc = Tc_{CH4} \\cdot \\left(1 + \\frac{1}{4} \\cdot (1 - \\sqrt{M})\\right) \\] And for critical pressure (Pc): \\[ Pc = 67 \\cdot \\left(1 - \\sqrt{M}\\right)^3 \\] Here’s Python code to calculate Tc and Pc using the Pitzer equation: # Constants for Pitzer equation Tc_CH4 = 190.6 # Critical temperature of methane in K M = 28.97 # Molecular weight of nitrogen (for example) # Calculate Tc and Pc using Pitzer equation Tc = Tc_CH4 * (1 + 1/4 * (1 - M**0.5)) # Critical temperature Pc = 67 * (1 - M**0.5)**3 # Critical pressure print(f&quot;Estimated Critical Temperature (Tc): {Tc} K&quot;) print(f&quot;Estimated Critical Pressure (Pc): {Pc} atm&quot;) 8.4 Review of Gas Properties 8.4.1 Real Gas law There are no gas that behaves as Ideal gas. The volume of Real gas is more that Ideal gas. The number that measure the amount of gas deviates from perfect gas is actually a ratio. this ratio is called as compressibility factor or gas deviation factor. this is a dimensionless quantity. If the gas deviation factor is not measured it can be estimated from the specific gravity of the gas. Sutton developed a correlation that estimates \\[\\begin{equation} \\tag{8.1} Ppc = 756.8 -131*Sg - 3.6 * Sg^2 \\\\ Tpc = 169.2 -349.5*Sg - 74 * Sg^2 \\end{equation}\\] We will write a small code to plot this correlation. import numpy as np import matplotlib.pyplot as plt Sg = np.arange(0.57,1.68,0.05) Ppc = [756.8 -131*sg - 3.6 * sg*sg for sg in Sg] Tpc = [169.2 + 349.5*sg - 74 * sg*sg for sg in Sg] plt.plot(Sg, Ppc, &#39;r-&#39;) [&lt;matplotlib.lines.Line2D object at 0x1290bdb20&gt;] plt.plot(Sg, Tpc, &#39;b-&#39;) [&lt;matplotlib.lines.Line2D object at 0x1290c8a30&gt;] plt.grid() plt.ylabel(&#39;Pseudo-critical Pressure and Temperature (psia and R)&#39;) Text(0, 0.5, &#39;Pseudo-critical Pressure and Temperature (psia and R)&#39;) plt.xlabel(&#39;Gas specific gravity&#39;) Text(0.5, 0, &#39;Gas specific gravity&#39;) plt.show() Wiechert-Aziz have developed a correlation to account for gases that contain CO2 and H2S \\[\\begin{equation} e = 120(A^{0.9} - A^{1.6}) + 15(B^{0.5} - B^4) \\end{equation}\\] A = sum of mole fraction of H2S and CO2 B = sum of mole fraction of H2S with this correation the modified equation becomes: \\[\\begin{equation} \\tag{8.2} T&#39;_{pc} = T_{pc} -e \\\\ P&#39;_{pc} = \\frac{P_{pc}T&#39;_{pc}}{(T_{pc}- B(1-B)e)} \\end{equation}\\] Lets assume H2S mole fraction of 0.05 and CO2 mole fraction of 0.1 and compare the plots # same code as above x_h2s=0.05 x_co2 =0.1 e = (120 * (((x_h2s + x_co2)**0.9) - ((x_h2s + x_co2)**1.6))) + (15 * (x_h2s**0.5 - x_h2s**4)) T_pc_corr = [T - e for T in Tpc] P_pc_corr = [(Ppc[i] * T_pc_corr[i]) / (Tpc[i] - x_h2s * e * (1-x_h2s)) for i in range(len(Tpc))] fig, ax = plt.subplots() ax.plot(Sg, Ppc, &#39;r-&#39;) [&lt;matplotlib.lines.Line2D object at 0x1290dad60&gt;] ax.plot(Sg, Tpc, &#39;b-&#39;) [&lt;matplotlib.lines.Line2D object at 0x1290dabb0&gt;] ax.plot(Sg, P_pc_corr, &#39;r--&#39;) [&lt;matplotlib.lines.Line2D object at 0x1290bd700&gt;] ax.plot(Sg, T_pc_corr, &#39;b--&#39;) [&lt;matplotlib.lines.Line2D object at 0x129095730&gt;] ax.grid() plt.ylabel(&#39;Pseudo-critical Pressure and Temperature (psia and R)&#39;) Text(0, 0.5, &#39;Pseudo-critical Pressure and Temperature (psia and R)&#39;) plt.xlabel(&#39;Gas specific gravity&#39;) Text(0.5, 0, &#39;Gas specific gravity&#39;) plt.show() 8.4.2 Gas z Factor The gas compressibility factor is a critical parameter in gas reservoir engineering, and below correlations provide approximations for its calculation. Please note that the accuracy of these correlations may vary depending on the specific gas mixture and conditions. 8.4.2.1 Dranchuk and Aboukassem equation of state The form of equation is as follow: \\[\\begin{equation} \\begin{split} z = 1 + c_{1}(T_{pr}) p_{r} + c_{2}(T_{pr})p_{r}^2 - c_{3}(T_{pr})p_{r}^5 + c_{4}(T_{pr}p_{r}) \\\\ where : \\\\ p_{r} = 0.27 P_{pr}/(zT_{pr}) \\\\ c_{1}(T_{pr}) = A_{1} + A_{2}/T_{pr} + A_{3}/T_{pr}^3 + A_{4}/T_{pr}^4 + A_{5}/T_{pr}^5\\\\ c_{2}(T_{pr}) = A_{6} + A_{7}/T_{pr} + A_{8}/T_{pr}^2 \\\\ c_{3}(T_{pr}) = A_{9}(A_{7}/T_{pr} + A_{8}/T_{pr}^2) \\\\ c_{4}(T_{pr}p_{r}) = A_{10}( 1 + A_{11}p_{r}^2)(p_{r}^2/T_{pr}^3) exp(-A_{11}p_{r}^2) \\\\ \\end{split} \\tag{8.3} \\end{equation}\\] where \\[\\begin{equation} A_{1} = 0.3265; A_{2} = -1.0700; A_{3} = -0.5339; A_{4} = 0.01569; A_{5} = -0.05165; A_{6} = 0.5475 \\\\ A_{7} = -0.7361; A_{8} = 0.1844; A_{9} = 0.1056; A_{10} = 0.6134; A_{11} = 0.7210 \\end{equation}\\] The above equation has z-factor on both side of the equation. To solve such equation a trial and error solution is required. However, in Python we can solve this equation using fsolve function of scipy library, which is a non-linear solver. import numpy as np from scipy.optimize import fsolve # non-linear solver def getZ_dranchuk(T_pr, P_pr): a1 = 0.3265; a2 = -1.0700; a3 = -0.5339; a4 = 0.01569; a5 = -0.05165; a6 = 0.5475 a7 = -0.7361; a8 = 0.1844; a9 = 0.1056; a10 = 0.6134; a11 = 0.7210 def func(y): rho_pr, z = y c1 = a1 + (a2/T_pr) + (a3/(T_pr**3))+ (a4/(T_pr**4))+ (a5/(T_pr**5)) c2 = a6 + (a7/T_pr) + (a8/(T_pr**2)) c3 = a9*((a7/T_pr) + (a8/(T_pr**2))) c4 = (a10)*(1+(a11*(rho_pr**2)))*((rho_pr**2)/(T_pr**3))*(np.exp(-a11*(rho_pr**2))) f1 = z + (c3*(rho_pr**5)) - (c2*(rho_pr**2)) - (c1*(rho_pr**1)) - c4 - 1 f2 = rho_pr - ((0.27 * P_pr) / (z * T_pr)) return[f1, f2] def dranchuk(): solve = fsolve(func, [1, 1]) # initial guess return(solve[0], solve[1]) return dranchuk()[1] # lets Assume T_pr = 1.8 P_pr = 4.87 print(f&#39;Gas Deviation factor Z : = {getZ_dranchuk(T_pr, P_pr)}&#39;) Gas Deviation factor Z : = 0.9110107290176761 8.4.2.2 Standing-Katz Correlation The Standing-Katz correlation provides an empirical estimation of the gas compressibility factor (Z) for natural gases. It is based on a set of constants and the deviation factor (F) for the gas: \\[ Z = 1 + \\left(\\frac{0.27}{P}\\right) \\cdot F \\] Where: - \\(P\\) is the pressure in psia (pounds per square inch absolute). - \\(F\\) is the deviation factor calculated based on the specific gravity (SG) of the gas. Here’s Python code to calculate Z using the Standing-Katz correlation: # Constants for Standing-Katz correlation P_psia = 1450.0 # Pressure in psia SG = 0.75 # Specific gravity of the gas # Calculate the deviation factor F based on SG if SG &lt; 0.6: F = 0.933 + 0.1395 * SG + 0.0167 * SG**2 else: F = 0.315 + 0.622 * SG - 0.216 * SG**2 # Calculate Z using the Standing-Katz correlation Z = 1 + (0.27 / P_psia) * F print(f&quot;Estimated Gas Compressibility Factor (Z) using Standing-Katz Correlation: {Z}&quot;) 8.4.2.3 Carr-Rossi-Lopez Correlation The Carr-Rossi-Lopez (CRL) correlation provides an empirical estimation of the gas compressibility factor (Z) for natural gases. It uses a set of constants and the deviation factor (F) for the gas: \\[ Z = 1 + \\left(\\frac{0.1}{P}\\right) \\cdot F \\] Where: - \\(P\\) is the pressure in psia (pounds per square inch absolute). - \\(F\\) is the deviation factor calculated based on the specific gravity (SG) of the gas. Here’s Python code to calculate Z using the Carr-Rossi-Lopez (CRL) correlation: # Constants for Carr-Rossi-Lopez (CRL) correlation P_psia = 1450.0 # Pressure in psia SG = 0.85 # Specific gravity of the gas # Calculate the deviation factor F based on SG F = 0.91 + 0.105 * SG # Calculate Z using the Carr-Rossi-Lopez (CRL) correlation Z = 1 + (0.1 / P_psia) * F print(f&quot;Estimated Gas Compressibility Factor (Z) using Carr-Rossi-Lopez (CRL) Correlation: {Z}&quot;) 8.4.3 Gas Density Density of a real gas can be calculated using the formula given below: \\[\\begin{equation} \\tag{8.4} \\rho_g = \\frac{1}{v} = \\frac{pM_a}{zRT} \\end{equation}\\] Using the data in below assuming real gas behavior, let’s calculate the density of the gas phase under initial reservoir conditions. # Component [CO2, N2, C1, C2, C3, i-C4, n-c4] gasComposition = [0.02, 0.01, 0.85, 0.04, 0.03, 0.03, 0.02] MW = [44.01, 28.01, 16.04, 30.1, 44.1, 58.1, 58.1] Tc = [547.91, 227.49 , 343.33, 549.92, 666.06, 734.46, 765.62] #Rankine Pc = [1071, 493.1, 666.4, 706.5, 616.4, 527.9, 550.6] Ma = sum([y*M for y, M in zip(gasComposition, MW)]) Tpc = sum([y*T for y, T in zip(gasComposition, Tc)]) Ppc = sum([y*P for y, P in zip(gasComposition, Pc)]) P = 3000 # Reservoir Pressure in psi T = 640 # Reservoir Temperature in R R = 10.73 # T_pr = T/Tpc P_pr = P/Ppc Z = getZ_dranchuk(T_pr, P_pr) density = P*Ma/(Z*R*T) # Results print(&#39;-&#39;*50) -------------------------------------------------- print(f&#39;Apparent molecular weight : = {round(Ma, 2)}&#39;) Apparent molecular weight : = 20.23 print(f&#39;Pseudo-critical pressure : = {round(Ppc, 2)} psi&#39;) Pseudo-critical pressure : = 666.39 psi print(f&#39;Pseudo-critical temperature : = {round(Tpc, 2)} R&#39;) Pseudo-critical temperature : = 384.39 R print(f&#39;Pseudo-reduced pressure : = {round(P_pr, 2)}&#39;) Pseudo-reduced pressure : = 4.5 print(f&#39;Pseudo-reduced temperature : = {round(T_pr, 2)}&#39;) Pseudo-reduced temperature : = 1.66 print(f&#39;Gas Deviation factor : = {round(Z, 2)}&#39;) Gas Deviation factor : = 0.86 print(f&#39;Gas Density : = {round(density, 2)} lb/ft3&#39;) Gas Density : = 10.28 lb/ft3 8.4.3.1 Benedict-Webb-Rubin (BWR) Equation of State The Benedict-Webb-Rubin (BWR) equation of state is a comprehensive model to estimate gas density (ρ) considering real gas behavior. The equation is quite complex and involves numerous constants and terms. It is often used in software packages designed for reservoir engineering simulations. The BWR equation of state for gas density (ρ) is: \\[ \\rho = \\frac{0.27 P}{ZRT} \\left(1 + \\frac{Tc}{T} \\left(\\frac{dZ}{dT}\\right)_P\\right) \\] Where: - \\(\\rho\\) is the gas density. - \\(P\\) is the pressure. - \\(Z\\) is the gas compressibility factor. - \\(R\\) is the gas constant. - \\(T\\) is the absolute temperature. - \\(Tc\\) is the critical temperature. - \\(\\left(\\frac{dZ}{dT}\\right)_P\\) is the derivative of the compressibility factor with respect to temperature at constant pressure. Calculating \\(\\left(\\frac{dZ}{dT}\\right)_P\\) involves a complex iterative process and is typically done using specialized software. Due to its complexity, engineers often rely on software or reservoir simulators to apply the BWR equation of state. 8.4.3.1.1 Standing-Katz Equation The Standing-Katz equation offers an empirical estimate of gas density (ρ) based on the gas compressibility factor (Z): \\[ \\rho = \\frac{0.00277 Z M}{T} \\] Where: - \\(\\rho\\) is the gas density. - \\(Z\\) is the gas compressibility factor. - \\(M\\) is the molecular weight of the gas. - \\(T\\) is the absolute temperature. Here’s Python code to calculate ρ using the Standing-Katz equation: # Constants for Standing-Katz equation Z = 0.95 # Compressibility factor M = 28.97 # Molecular weight of nitrogen (for example) T = 273.15 # Temperature in K # Calculate ρ using the Standing-Katz equation rho = (0.00277 * Z * M) / T print(f&quot;Estimated Gas Density (ρ) using Standing-Katz Equation: {rho} g/L&quot;) 8.4.3.2 Correlation 5: Papp’s Equation Papp’s equation offers an empirical estimate of gas density (ρ) based on gas-specific parameters: \\[ \\rho = \\frac{Z \\cdot M}{T \\cdot 10^{6} \\cdot P} \\] Where: - \\(\\rho\\) is the gas density. - \\(Z\\) is the gas compressibility factor. - \\(M\\) is the molecular weight of the gas. - \\(T\\) is the absolute temperature. - \\(P\\) is the pressure in psia. Here’s Python code to calculate ρ using Papp’s equation: # Constants for Papp&#39;s equation Z = 0.95 # Compressibility factor M = 28.97 # Molecular weight of nitrogen (for example) T = 273.15 # Temperature in K P_psia = 14.5 # Pressure in psia # Calculate ρ using Papp&#39;s equation rho = (Z * M) / (T * 10**6 * P_psia) print(f&quot;Estimated Gas Density (ρ) using Papp&#39;s Equation: {rho} g/L&quot;) 8.4.4 Isothermal Gas Compressibility Isothermal compressibility is defined as change in volume with pressure for gas under isothermal condition. \\[\\begin{equation} \\tag{8.5} V = znR&#39;T/P \\\\ or \\\\ V = constant * z/P \\end{equation}\\] Mattar, Brar, and Aziz developed an analytical expression for calculating pseudo-reduced compressibility. By taking the derivative of equation of state developed by Dranchuck and Abou-Kassem developed the following equation. # code for Isothermal Gas Compressibility using Dranchuck and Abou-Kassem equation import numpy as np a1 = 0.3265; a2 = -1.0700; a3 = -0.5339; a4 = 0.01569; a5 = -0.05165; a6 = 0.5475 a7 = -0.7361; a8 = 0.1844; a9 = 0.1056; a10 = 0.6134; a11 = 0.7210 def mattar(T_pr, P_pr, rho_pr, z, P_pc_corr): do = ((a1 + (a2/T_pr) + (a3/T_pr**3) +(a4/T_pr**4) + (a5/T_pr**5)) * rho_pr) + \\ (2 * ((a6 + (a7/T_pr) + (a8/T_pr**2))) * rho_pr**2) - \\ (5 * a9 * (((a7/T_pr) + (a8/T_pr**2))) * rho_pr**4) + (1 + (a11 * rho_pr**2) - (a11 * rho_pr**2)**2) \\ * ((2 * a10 * rho_pr / T_pr**3)*np.exp(-a11 * rho_pr**2)) c_pr_analytical = (1 / P_pr) - ((0.27 / (z**2 * T_pr)) * (do / (1 + ((rho_pr / z) * do)))) cgas_analytical = c_pr_analytical / P_pc_corr return(cgas_analytical) print(mattar(1.44, 7.08, 0.80, 0.91, 636)) 0.00021157987661567598 8.4.5 Gas formation volume factor 8.4.5.1 Ideal Gas Law The ideal gas law offers a simple estimate of the gas formation volume factor (Bg) assuming ideal gas behavior: \\[ Bg = \\frac{1}{Z} \\] Where: - \\(Bg\\) is the gas formation volume factor. - \\(Z\\) is the gas compressibility factor. Here’s Python code to calculate Bg using the ideal gas law: # Constants for ideal gas law Z = 0.95 # Compressibility factor # Calculate Bg using the ideal gas law Bg = 1 / Z print(f&quot;Estimated Gas Formation Volume Factor (Bg) using Ideal Gas Law: {Bg} RB/STB&quot;) 8.4.5.2 Real Gas Law Gas formation volume factor relates the volume of gas in the reservoir to the volume of gas on the surface at standard conditions so, Bg can be written as Bg = 0.02829 zT/p in ft3/scf = 0.00504 zT/P bbl/scf. z= 0.91 P = 3250 # psia T = 213 # F Bg = 0.02829*z*(T+460)/P print (f&#39;Gas formation volume Factor : {Bg}&#39;) Gas formation volume Factor : 0.005330967600000001 "],["properties-of-oil.html", "9 Properties of Oil", " 9 Properties of Oil Basic oil properties from compositions The properties of mixture of oil can be calculated from molar fraction of individual components. for example # lets take four component names = [&#39;C3&#39;, &#39;nC4&#39;, &#39;nC5&#39;, &#39;nC6&#39;] # name of component frac = [0.05, 0.15, 0.2, 0.6] # volume fraction rho = [507.2, 583.9, 629.5, 659.8] # Mass density MW = [44.09, 58.12, 72.15, 86.17] # Molecular weight ncomp = len(names) m = [rho[i]*frac[i] for i in range(ncomp)] # Mass of each component n = [m[i]/MW[i] for i in range (ncomp)] # MOles of each component Mass = sum(m) moles = sum(n) w = [m[i]/ Mass for i in range(ncomp)] # Weight Fraction mol_frac = [n[i]/ moles for i in range(ncomp)] # Mole fraction Total_MW = Mass / moles # Molecular weight of total composition Sg = Mass / 1000 # specific gravity API = 141.5 / Sg - 131.5 # Oil API print(&#39;Mixture MW:&#39;, round(Total_MW,3), &#39;lbm/lbm mol&#39;) Mixture MW: 75.371 lbm/lbm mol print(&#39;Mixture Density:&#39;, round(Mass, 3), &#39;kg/m3&#39;) Mixture Density: 634.725 kg/m3 print(&#39;Mixture SG::&#39;, round(Sg ,3)) Mixture SG:: 0.635 print(&#39;degrees API:&#39;, round(API,3), &#39;API&#39;) degrees API: 91.431 API "],["rock-properties.html", "10 Rock Properties 10.1 Surface and Interfacial Tension 10.2 Capillary Pressure 10.3 Leverett J-Function 10.4 Permeability 10.5 Reservoir Heterogeneity", " 10 Rock Properties 10.1 Surface and Interfacial Tension In dealing with multiphase systems, it is necessary to consider the effect of the forces at the interface when two immiscible fluids are in contact. When these two fluids are liquid and gas, the term surface tension is used to describe the forces acting on the interface. When the interface is between two liquids, the acting forces are called interfacial tension. The surface or interfacial tension has the units of force per unit of length, e.g., dynes/cm, Assuming the radius of the capillary tube is r, the total upward force Fup, which holds the liquid up, is equal to the force per unit length of surface times the total length of surface, or \\[\\begin{equation} \\tag{10.1} F_{up} = 2\\pi r \\sigma_{gw} (cos\\theta) \\end{equation}\\] where sigma_gw = surface tension between air (gas) and water (oil). dynes/cm theta = contact angle r = radius, cm The upward force is counteracted by the weight of the water, which is equivalent to a downward force of mass times acceleration, or \\[\\begin{equation} \\tag{10.2} F_{down} = \\pi r^2 h (\\rho_{w} -\\rho_{air})g \\end{equation}\\] where h = height to which the liquid is held, cm g = acceleration due to gravity, cm/sec2 Rho_w = density of water, gm/cm3 Rho_air = density of gas, gm/cm3 Equating (10.1) and (10.2) solving for the surface tension when applying for two liquids, i.e., water and oil this equation becomes: \\[\\begin{equation} \\tag{10.3} \\rho_{ow} = \\frac{rhg(\\rho_{w} -\\rho_{o})}{2cos\\theta} \\end{equation}\\] 10.2 Capillary Pressure The capillary forces in a petroleum reservoir are the result of the combined effect of the surface and interfacial tensions of the rock and fluids, the pore size and geometry, and the wetting characteristics of the system. Any curved surface between two immiscible fluids has the tendency to contract into the smallest possible area per unit volume. This is true whether the fluids are oil and water, water and gas. The displacement of one fluid by another in the pores of a porous medium is either aided or opposed by the surface forces of capillary pressure. As a consequence, in order to maintain a porous medium partially saturated with nonwetting fluid and while the medium is also exposed to wetting fluid, it is necessary to maintain the pressure of the nonwetting fluid at a value greater than that in the wetting fluid Capillary pressure = (pressure of the nonwetting phase) - (pressure of the wetting phase) There are three types of capillary pressure: - Water-oil capillary pressure (denoted as Pcwo) - Gas-oil capillary pressure (denoted as Pcgo) - Gas-water capillary pressure (denoted as Pcgw) In practical units, Capillary pressure is written as \\[\\begin{equation} \\tag{10.4} P_c = \\frac{h}{144} \\Delta \\rho \\end{equation}\\] where Pc = capillary pressure, psi   h = capillary rise, ft   Delta_rho = density difference, lb/ft3   Exercise 10.1 Calculate the pressure difference, i.e., capillary pressure, and capillary rise in an oil-water system from the following data: theta = 30° rhow = 1.0 gm/cm3 rhooil = 0.75 gm/cm3 r = 0.0001 cm sigma = 25 dynes/cm import math theta = 30 rhow = 1.0 # gm/cm3 rhooil = 0.75 #gm/cm3 r = 0.0001 #cm sigma = 25 #dynes/cm Pc = 2* sigma * math.cos(math.pi*theta/180)/r h = 2* sigma * math.cos(math.pi*theta/180)/(r*980.7*(1-0.75)) print(f&#39;capillary pressure : = {Pc} dynes/cm2 &#39;) capillary pressure : = 433012.70189221937 dynes/cm2 # Since 1 dyne/cm2 = 1.45 * 10^-5 psi, then print(f&#39;capillary pressure : = {Pc * 1.45*10**(-5)} psi &#39;) capillary pressure : = 6.278684177437181 psi print(f&#39; Capillary rise : = {h} cm &#39;) Capillary rise : = 1766.1372566216758 cm print(f&#39; Capillary rise : = {h* 0.032808} ft &#39;) Capillary rise : = 57.94343111524393 ft Capillary Hysteresis It is generally agreed that the pore spaces of reservoir rocks were originally filled with water, after which oil moved into the reservoir, displacing some of the water and reducing the water to some residual saturation. When discovered, the reservoir pore spaces are filled with a connatewater saturation and an oil saturation. The process of generating the capillary pressure curve by displacing the wetting phase, i.e., water, with the nonwetting phase (such as with gas or oil), is called the drainage process. The other principal flow process of interest involves reversing the drainage process by displacing the nonwetting phase (such as with oil) with the wetting phase. This displacing process is termed the imbibition process and the resulting curve is termed the capillary pressure imbibition curve. The two capillary pressure-saturation curves are not the same. This difference in the saturating and desaturating of the capillary-pressure curves is closely related to the fact that the advancing and receding contact angles of fluid interfaces on solids are different Initial Saturation Distribution in a Reservoir An important application of the concept of capillary pressures pertains to the fluid distribution in a reservoir prior to its exploitation Figure ?? illustrates an idealized gas, oil, and water distribution in a reservoir. The figure indicates that the saturations are gradually charging from 100% water in the water zone to irreducible water saturation some vertical distance above the water zone. This vertical area is referred to as the transition zone, which must exist in any reservoir where there is a bottom water table. The transition zone is then defined as the vertical thickness over which the water saturation ranges from 100% saturation to irreducible water saturation. The WOC is defined as the “uppermost depth in the reservoir where a 100% water saturation exists.” It should be noted that there is a difference between the free water level (FWL) and the depth at which 100% water saturation exists. From a reservoir engineering standpoint, the free water level is defined by zero capillary pressure. Obviously, if the largest pore is so large that there is no capillary rise in this size pore, then the free water level and 100% water saturation level, i.e., WOC, will be the same. mathematically \\[\\begin{equation} \\tag{10.5} FWL = WOC + \\frac{144 p_d}{\\Delta \\rho} \\end{equation}\\] where pd = displacement pressure, psi delta rho = density difference, lb/ft3 FWL = free water level, ft WOC = water-oil contact, ft 10.3 Leverett J-Function Capillary pressure data are obtained on small core samples that represent an extremely small part of the reservoir and, therefore, it is necessary to combine all capillary data to classify a particular reservoir. The fact that the capillary pressure-saturation curves of nearly all naturally porous materials have many features in common has led to attempts to devise some general equation describing all such curves. Leverett (1941) approached the problem from the standpoint of dimensional analysis. Realizing that capillary pressure should depend on the porosity, interfacial tension, and mean pore radius, Leverett defined the dimensionless function of saturation, which he called the J-function. \\[\\begin{equation} \\tag{10.6} J(S_w) = 0.21645 \\frac{p_c}{\\sigma} \\sqrt\\frac{k}{\\phi} \\end{equation}\\] where J(Sw) = Leverett J-function pc = capillary pressure, psi sigma = interfacial tension, dynes/cm k = permeability, md   phi = fractional porosity Exercise 10.2 A laboratory capillary pressure test was conducted on a core sample taken from the Nameless Field. The core has a porosity and permeability of 16% and 80 md, respectively. The capillary pressure-saturation data are given as follows: Sw = [1.0, 0.8, 0.6, 0.4, 0.2] Pc = [0.5, 0.6, 0.75, 1.05, 1.75] The interfacial tension is measured at 50 dynes/cm. Further reservoir engineering analysis indicated that the reservoir is better described at a porosity value of 19% and an absolute permeability of 120 md. Generate the capillary pressure data for the reservoir. import math Sw = [1.0, 0.8, 0.6, 0.4, 0.2] Pc = [0.5, 0.6, 0.75, 1.05, 1.75] Jsw = [0.21645*(pc /50)*math.sqrt(80/0.16) for pc in Pc] Pc_reservoir = [J*50/(0.21645 * math.sqrt(120/0.19)) for J in Jsw] print(Pc_reservoir ) [0.44487826050130475, 0.5338539126015657, 0.6673173907519571, 0.9342443470527398, 1.5570739117545664] 10.4 Permeability Permeability is a property of the porous medium that measures the capacity and ability of the formation to transmit fluids. The rock permeability, k, is a very important rock property because it controls the directional movement and the flow rate of the reservoir fluids in the formation. This rock characterization was first defined mathematically by Henry Darcy in 1856. In fact, the equation that defines permeability in terms of measurable quantities is called Darcy’s Law. Darcy developed a fluid flow equation that has since become one of the standard mathematical tools of the petroleum engineer. If a horizontal linear flow of an incompressible fluid is established through a core sample of length L and a cross-section of area A, then the governing fluid flow equation is defined as \\[\\begin{equation} \\tag{10.7} \\nu = - \\frac{k}{\\mu}\\frac{\\Delta P}{\\Delta L} \\end{equation}\\] where   v = apparent fluid flowing velocity, cm/sec k = proportionality constant, or permeability, Darcys m = viscosity of the flowing fluid, cp dp/dL = pressure drop per unit length, atm/cm The velocity, v, in Equation (10.7) is not the actual velocity of the flowing fluid but is the apparent velocity determined by dividing the flow rate by the cross-sectional area across which fluid is flowing. Substituting the relationship, q/A, in place of v. \\[\\begin{equation} \\tag{10.8} q = - \\frac{kA}{\\mu}\\frac{\\Delta P}{\\Delta L} \\end{equation}\\] Exercise 10.3 A brine is used to measure the absolute permeability of a core plug. The rock sample is 4 cm long and 3 cm2 in cross section. The brine has a viscosity of 1.0 cp and is flowing a constant rate of 0.5 cm3/sec under a 2.0 atm pressure differential. Calculate the absolute permeability Q = 0.5 A = 3 L = 4 mu = 1 dp = 2 K = Q * mu * L /(dp*A) print(f&#39;Absolute permeability := {K} darcys&#39; ) Absolute permeability := 0.3333333333333333 darcys In using dry gas in measuring the permeability, the gas volumetric flow rate q varies with pressure because the gas is a highly compressible fluid. Therefore, the value of q at the average pressure in the core must be used in Equation (10.8). Assuming the used gases follow the ideal gas behavior (at low pressures), the following relationships apply. The gas flow rate is usually measured at base (atmospheric) pressure pb and, therefore, the term Qgsc is introduced to produce \\[\\begin{equation*} Q_{gsc} P_b = q_m p_m \\end{equation*}\\] Substituting Darcy’s Law (10.8) in the above expression gives. \\[\\begin{equation*} Q_{gsc} P_b = \\frac{kA(p_1 - p_2)}{\\mu_g L}\\frac{p_1 + p_2}{2} \\end{equation*}\\] or \\[\\begin{equation} \\tag{10.9} Q_{gsc} = \\frac{kA(p^2_{1} - p^2_2)}{2 \\mu_g L P_b} \\end{equation}\\] where k = absolute permeability, Darcys mg = gas viscosity, cp pb = base pressure, atm p1 = inlet (upstream) pressure, atm p2 = outlet (downstream) pressure, atm L = length of the core, cm A = cross-sectional area, cm2 Qgsc = gas flow rate at standard conditions, cm3/sec The Klinkenberg Effect Klinkenberg (1941) discovered that permeability measurements made with air as the flowing fluid showed different results from permeability measurements made with a liquid as the flowing fluid. The permeability of a core sample measured by flowing air is always greater than the permeability obtained when a liquid is the flowing fluid. Klinkenberg postulated, on the basis of his laboratory experiments, that liquids had a zero velocity at the sand grain surface, while gases exhibited some finite velocity at the sand grain surface. In other words, the gases exhibited slippage at the sand grain surface. This slippage resulted in a higher flow rate for the gas at a given pressure differential. The magnitude of the Klinkenberg effect varies with the core permeability and the type of the gas used in the experiment. Klinkenberg suggested a relation between gas permeability and liquid permeability. \\[\\begin{equation} \\tag{10.10} K_g = K_L + bK_L\\frac{1}{p_m} \\end{equation}\\] Jones (1972) studied the gas slip phenomena for a group of cores for which porosity, liquid permeability kL (absolute permeability), and air permeability were determined. He correlated the parameter b with the liquid permeability by the following expression: \\[\\begin{equation} \\tag{10.11} b = 6.9K^{-0.36}_L \\end{equation}\\] by combining (10.10) and (10.11) we get: \\[\\begin{equation} \\tag{10.12} 6.9K^{0.64}_L + p_m K_L -p_g K_g = 0 \\end{equation}\\] This nonlinear equation (10.12) can be solved iteratively. Exercise 10.4 The permeability of a core plug is measured by air. Only one measurement is made at a mean pressure of 2.152 psi. The air permeability is 46.6 md. Estimate the absolute permeability of the core sample. from scipy.optimize import fsolve def fun_Klink(K): pm = 2.152 Kg = 46.6 return 6.9*K[0]**0.64 + pm *K[0] - pm* Kg root = fsolve(fun_Klink, [30]) print(f&#39;Liquid permeability := {root[0]}&#39;) Liquid permeability := 22.849002279471133 10.5 Reservoir Heterogeneity The reservoir heterogeneity is then defined as a variation in reservoir properties as a function of space. Ideally, if the reservoir is homogeneous, measuring a reservoir property at any location will allow us to fully describe the reservoir. The task of reservoir description is very simple for homogeneous reservoirs. On the other hand, if the reservoir is heterogeneous, the reservoir properties vary as a function of a spatial location. These properties may include permeability, porosity, thickness, saturation, faults and fractures, rock facies and rock characteristics. There are essentially two types of heterogeneity: Vertical heterogeneity Areal heterogeneity here we will discuss heterogeneity of the reservoir in terms of permeability. 10.5.1 Vertical Heterogeneity Permeabilities pose problems because they usually vary by more than an order of magnitude between different strata. It is appropriate to be able to describe the degree of heterogeneity within a particular system in quantitative terms. The degree of homogeneity of a reservoir property is a number that characterizes the departure from uniformity or constancy of that particular measured property through the thickness of reservoir. The following are the two most widely used descriptors of the vertical heterogeneity of the formation; Dykstra-Parsons permeability variation V Lorenz coefficient L The Dykstra-Parsons Permeability Variation Dykstra and Parsons (1950) introduced the concept of the permeability variation coefficient V which is a statistical measure of non-uniformity of a set of data. It is generally applied to the property of permeability but can be extended to treat other rock properties. It is generally recognized that the permeability data are log-normally distributed. Dykstra and Parsons recognized that the geologic processes that create permeability in reservoir rocks appear to leave permeabilities distributed around the geometric mean. The required computational steps for determining the coefficient V are summarized below: Arrange the core samples in decreasing permeability sequence For each sample, calculate the percentage of thickness with permeability greater than this sample plot permeability values on the log scale and the % of thickness on the probability scale Draw the best straight line through the points Read the corresponding permeability values at 84.1% and 50% of thickness The Dykstra-Parsons permeability variation is defined follows \\[\\begin{equation} \\tag{10.13} V = \\frac{K_{50}-K_{84.1}}{K_{50}} \\end{equation}\\] Exercise 10.5 Calculate the Dykstra-Parsons permeability variation for the following data: K = [435.0, 254.0, 196.0, 172.0, 166.0, 158.0, 153.0, 147.0, 128.0, 105.0, 100.0, 91.0, 90.0, 83.0, 72.0 , 62.0, 49.0, 44.0, 40.0, 35.0, 32.0, 30.0, 28.0, 27.0, 20.0, 9.0] h = [2.0, 2.0, 2.0, 3.0, 2.0, 2.0, 2.0, 2.0, 1.0, 2.0, 1.0, 2.5, 2.5, 2.0, 1.5, 2.0, 6.5, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0] from numpy import cumsum import math from scipy.optimize import curve_fit K = [435.0, 254.0, 196.0, 172.0, 166.0, 158.0, 153.0, 147.0, 128.0, 105.0, 100.0, 91.0, 90.0, 83.0, 72.0 , 62.0, 49.0, 44.0, 40.0, 35.0, 32.0, 30.0, 28.0, 27.0, 20.0, 9.0] h = [2.0, 2.0, 2.0, 3.0, 2.0, 2.0, 2.0, 2.0, 1.0, 2.0, 1.0, 2.5, 2.5, 2.0, 1.5, 2.0, 6.5, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0] cum_h = list(cumsum(h)) max_h = max(cum_h) percent_h = [x*100/max_h for x in cum_h] sublist_K = [math.log(K[idx]) for idx in range(len(percent_h)) if (percent_h[idx]&gt;40) &amp; (percent_h[idx]&lt;90) ] sublist_h = [percent_h[idx] for idx in range(len(percent_h)) if (percent_h[idx]&gt;40) &amp; (percent_h[idx]&lt;90) ] def line(x, a, b): return a*x + b popt, _ = curve_fit(line, sublist_h, sublist_K) K_50 = math.exp(line(50, popt[0], popt[1])) K_84 = math.exp(line(84.1, popt[0], popt[1])) print(K_50) 77.69782663561321 print(K_84) 31.19170566405657 V = (K_50- K_84)/K_50 print(V) 0.5985511176478688 It should be noted that if all the permeabilities are equal, the numerator or (10.13) would be zero, and the V would also be zero. This would be the case for a completely homogeneous system. Lorenz Coefficient L Schmalz and Rahme (1950) introduced a single parameter that describes the degree of heterogeneity within a pay zone section. The term is called Lorenz coefficient and varies between zero, for a completely homogeneous system, to one for a completely heterogeneous system. The following steps summarize the methodology of calculating Lorenz coefficient. - Arrange all the available permeability values in a descending order. - Calculate the cumulative permeability capacity and cumulative volume capacity - Calculate the cumulative permeability capacity Skh and cumulative volume capacity. - Plot the normalized cumulative permeability capacity versus the normalized cumulative volume capacity on a Cartesian scale. A completely uniform system would have all permeability’s equal, and a plot of the normalized capacities would be a straight line. The plot can be used to describe the reservoir heterogeneity quantitatively by calculating the Lorenz coefficient. The coefficient is defined by the following expression: L = Area above straight line / Area below straight line for homogeneous reservoir Area above straight line is zero hence L=0 and for completely heterogeneous reservoir area above = area below thus L=1; Exercise 10.6 Using data given in exercise 10.5 calculate Lorenz Coefficient. from scipy import integrate KH = [K[i]*h[i] for i in range(len(h))] Norm_KH = [(max(KH)-KH[i])/(max(KH)-min(KH)) for i in range(len(h))] Norm_h = [(percent_h[i]- min(percent_h))/(max(percent_h)-min(percent_h)) for i in range(len(h))] Area = integrate.simpson(Norm_KH, Norm_h) &lt;string&gt;:1: DeprecationWarning: You are passing x=[np.float64(0.0), np.float64(0.037037037037037035), np.float64(0.07407407407407407), np.float64(0.12962962962962965), np.float64(0.16666666666666663), np.float64(0.2037037037037037), np.float64(0.2407407407407407), np.float64(0.27777777777777773), np.float64(0.2962962962962963), np.float64(0.33333333333333337), np.float64(0.35185185185185186), np.float64(0.3981481481481482), np.float64(0.4444444444444445), np.float64(0.4814814814814815), np.float64(0.5092592592592593), np.float64(0.5462962962962963), np.float64(0.6666666666666667), np.float64(0.7037037037037037), np.float64(0.7407407407407407), np.float64(0.7777777777777778), np.float64(0.8148148148148148), np.float64(0.8518518518518517), np.float64(0.888888888888889), np.float64(0.9259259259259259), np.float64(0.962962962962963), np.float64(1.0)] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error. print(Area) 0.7655482644601385 L = (Area - 0.5)/0.5 print(L) 0.5310965289202769 "],["relative-permeability.html", "11 Relative Permeability 11.1 Three-phase relative permeability 11.2 Simplified Fractional Flow Equation 11.3 Buckley-Leverett Theory", " 11 Relative Permeability The effective permeability of any reservoir fluid is a function of the reservoir fluid saturation and the wetting characteristics of the formation Relative Permeability from Analytical Equations Analytical representations for individual-phase relative permeabilities are commonly used in numerical simulators Oil-Water Systems \\[\\begin{equation} \\tag{11.1} K_{ro} = (K_{ro})_{sc} \\Big[\\frac{1- S_w - S_{orw}}{1 - S_{wc} - S_{orw}} \\Big]^{n_o} \\end{equation}\\] \\[\\begin{equation} \\tag{11.2} K_{rw} = (K_{rw})_{sorw} \\Big[\\frac{S_w - S_{wc}}{1 - S_{wc} - S_{orw}} \\Big]^{n_w} \\end{equation}\\] Currey Function fitting on experimental data Exercise 11.1 Fit Relative permeability curve on Analytical Equations (11.1) and (11.2) for the given end points and calculate the coefficients no and nw for oil and water. from scipy import optimize import pandas as pd import matplotlib.pyplot as plt Swc = 0.25 Swor = 0.35 Kro = 0.85 # kro at Swc Krw= 0.4 # Krw at Sorw def get_Ko(Sw, no): return Kro*((1-Sw-Swor)/(1-Swc-Swor))**no def get_Kw(Sw, nw): return Krw*((Sw-Swc)/(1-Swc-Swor))**nw df = pd.read_csv(&#39;data/Rel-Perm.csv&#39;) df[&#39;Ratio_Ko_kw&#39;] = df[&#39;Ko&#39;]/df[&#39;Kw&#39;] def test_func(Sw, no, nw): return Kro/Krw*(1-Swc-Swor)**(nw-no)*(1-Sw-Swor)**no/(Sw-Swc)**nw params, params_covariance = optimize.curve_fit(test_func, df[&#39;Sw&#39;], df[&#39;Ratio_Ko_kw&#39;],p0=[1.5, 4]) fig = plt.figure(figsize=(20, 10)) plt.plot(df[&#39;Sw&#39;], df[&#39;Ko&#39;], &#39;k^&#39;, ) plt.plot(df[&#39;Sw&#39;], df[&#39;Kw&#39;],&#39;k.&#39;) plt.xlim([0,1]) plt.ylim([0,1]) plt.plot(df[&#39;Sw&#39;], get_Ko(df[&#39;Sw&#39;], params[0]), &#39;r--&#39;) plt.plot(df[&#39;Sw&#39;], get_Kw(df[&#39;Sw&#39;], params[1]), &#39;b--&#39;) plt.legend((&#39;Ko&#39;, &#39;Kw&#39;, &#39;Ko fitted no = &#39; + str(round(params[0], 2)),&#39;Kw fitted nw = &#39;+ str(round(params[1], 2)) ),loc=&#39;upper center&#39;) plt.show() Exercise 11.2 Fit Relative permeability curve on the core data and generate calculate Kro and Krw at Sw = 0.567 # suppose we have experimental data of relative permeability and we want to curve fit on this data. from scipy import interpolate Sw = np.arange(0.2, 0.9, 0.05) krw = np.array([0, .002, .02, .04, .07, .11, .15, .22, .3, .4, .5, .6, .7, .8]) kro = np.array([.6, .5, .4, .3, .23, .17, .12, .08, .05, .03, .02, .01, .005, 0]) # Spline interpolation of data krw_interp = interpolate.splrep(Sw, krw, s=0) kro_interp = interpolate.splrep(Sw, kro, s=0) def get_Kro_Krw_at_sw(Sw_new): krw_new = interpolate.splev(Sw_new, krw_interp, der=0) kro_new = interpolate.splev(Sw_new, kro_interp, der=0) return krw_new, kro_new Sw_given = 0.567 # we want to find Kro and Krw at this saturation krw_cal, kro_cal = get_Kro_Krw_at_sw( Sw_given) print(f&#39;at given Sw : {Sw_given} Kro := {kro_cal} &amp; Krw := {krw_cal}&#39;) at given Sw : 0.567 Kro := 0.06870642488480108 &amp; Krw := 0.24588673312610348 11.1 Three-phase relative permeability In a three-phase system it is found that the relative permeability to water depends only upon the water saturation. Wyllie’s Correlations Wyllie (1961) proposed the following equations for three-phase relative permeabilities in a water-wet system: Calculate Fw curve The fractional flow of water is the ratio of water production rate to total production rate. In the case of an oil-water system, the fractional flow of water is given by: \\[\\begin{equation} f_{w} = \\frac{q_{w}}{q_{w} + q_{o} } \\tag{11.3} \\end{equation}\\] Notice that the flow rates are expressed in terms of reservoir volumes. The fractional flow of oil fw, and the fractional flow of water are related by fw= 1 - fw for an oil-water system. Based on the definition of fractional flow, we see that fractional flow should be a value between 0 and 1. 11.2 Simplified Fractional Flow Equation A simplified fractional flow equation is obtained by replacing flow rates with Darcy’s Law in the definition of fractional flow. If we neglect capillary pressure and gravity for simplicity, we obtain \\[\\begin{equation} q_{w} = \\frac{kk_{r_{w}}A}{\\mu_{w}}\\frac{\\partial P_{w}}{\\partial x} \\tag{11.4} \\end{equation}\\] where A is cross-sectional area and P is pressure of phase. Since capillary pressure is neglected, we have equal phase pressure so Pw = Po. if we put (11.4) in fractional flow equation given (11.3) and simplify it we will get \\[\\begin{equation} \\tag{11.5} f_{w} = \\frac{\\frac{k_{r_{w}}}{\\mu_{w}}}{\\frac{k_{r_{w}}}{\\mu_{w}} + \\frac{k_{r_{o}}}{\\mu_{o}}} \\end{equation}\\] Mobility of a phase can be defined as \\[\\begin{equation} \\tag{11.6} \\lambda_{w} = \\frac{k_{r_{w}}}{\\mu_{w}} \\end{equation}\\] expressing (11.5) in term of (11.6) \\[\\begin{equation} \\tag{11.7} f_{w} = \\frac{1}{1 + \\frac{\\lambda_{o}}{\\lambda_{w}}} \\end{equation}\\] # taking the data from above Sw = np.arange(0.2, 0.9, 0.01) muo = 0.25 # cp muw = 1 # cp Fw = list() for i in range (len(Sw)): krw_cal, kro_cal = get_Kro_Krw_at_sw( Sw[i]) if krw_cal == 0: Fw.append(0) else: Fw.append(1 / (1 + (kro_cal / muo) * (muw / krw_cal))) fig = plt.figure(figsize=(20, 10)) plt.plot(Sw, Fw, &#39;b-&#39;, ) plt.xlim([0,1]) plt.ylim([0,1]) plt.ylabel(&#39;fraction flow&#39;) plt.xlabel(&#39;Sw&#39;) plt.title(&#39;Fraction flow curve&#39;) plt.show() Calculate Fw Equation with Gravity Gravity can be included in the fractional flow equation as follows. First, let us consider the two-phase flow of oil and water in a tilted linear system. Darcy’s Law including capillary pressure and gravity effects for linear flow is \\[\\begin{equation} q_{w} = - \\frac{kk_{r_{w}}A}{\\mu_{w}}\\Bigg(\\frac{\\partial P_{w}}{\\partial x} + \\rho_{w}g\\sin\\alpha \\Bigg) \\\\ q_{o} = - \\frac{kk_{r_{o}}A}{\\mu_{o}}\\Bigg(\\frac{\\partial P_{o}}{\\partial x} + \\rho_{o}g\\sin\\alpha&#39; \\Bigg) \\tag{11.8} \\end{equation}\\] If we differentiate capillary pressure for a water-wet system with respect to position x along the dipping bed, we find \\[\\begin{equation} \\tag{11.9} \\frac{\\partial P_{cow}}{\\partial x} = \\frac{\\partial P_{o}}{\\partial x} -\\frac{\\partial P_{w}}{\\partial x} \\end{equation}\\] Rearranging and collecting terms gives the fractional flow to water fw in conventional oilfield units: \\[\\begin{equation} \\tag{11.10} f_{w} = \\frac{1+0.001127 \\frac{Akk_{ro}}{\\mu_{o}q_{t}}\\Big(\\frac{\\partial P_{cow}}{\\partial x} - 0.433(\\gamma_{w} - \\gamma_{o})\\sin\\alpha \\Big)}{1 + \\frac{k_{ro}}{k_{rw}}\\frac{\\mu_{w}}{\\mu_{o}}} \\end{equation}\\] where A cross-sectional area of flow system ft2, k absolute permeability md, kro relative permeability to oil, kw relative permeability to water, oil viscosity cp, water viscosity cp, Pcow oil-water capillary pressure psi = P0 - Pw, x direction of linear flow ft, alpha dip angle of formation degrees, gamma oil specific gravity (water =1), gamma water specific gravity (water = 1 ), 11.3 Buckley-Leverett Theory One of the simplest and most widely used methods of estimating the advance of a fluid displacement front in an immiscible displacement process is the Buckley-Leverett method. Buckley-Leverett Theory [1942] estimates the rate at which an injected water bank moves through a porous medium. The approach uses fractional flow theory and is based on the following assumptions: Flow is linear and horizontal Water is injected into an oil reservoir Oil and water are both incompressible Oil and water are immiscible Gravity and capillary pressure effects are negligible Frontal advance theory is an application of the law of conservation of mass. Flow through a small volume element with length x and cross-sectional area A The change in water saturation per unit time can be written as \\[\\begin{equation} \\tag{11.11} \\frac{\\partial S_{w}}{\\partial t} = \\frac{-q}{A \\phi} \\frac{\\partial f_{w}}{\\partial S_{w}}\\frac{\\partial S_{w}}{\\partial x} \\end{equation}\\] The python code to solve BL curve is given below def buckley_leverett1d(nt, Sw0, L, nx, sigma, bc_value, muw, muo, q, A, poro, Sw_data, krw_data, kro_data): &quot;&quot;&quot; Solve Buckley-Leverett PDE using forward-time/backward-space scheme &quot;&quot;&quot; def interstitial_velocity(q, A, poro): # interstitial velocity vt vt = q / A * poro return vt def fractional_flow(krw, muw, kro, muo): # fractional flow Fww Fww = 1 / (1 + (kro / muo) * (muw / krw)) return Fww # calculate interstitial velocity vt = interstitial_velocity(q, A, poro) # calculate dx dx = L / (nx - 1) # calculate dt from CFwL dt = sigma * dx / vt # time-step size # Discretize the domain. x = np.linspace(0.0, L, num=nx) # integrate solution in time Sw_hist = [Sw0.copy()] Sw = Sw0.copy() for n in range(nt): # Compute the fractional flow. krw, kro = get_Kro_Krw_at_sw(Sw) Fw = fractional_flow(krw, muw, kro, muo) # Advance in time. Sw[1:] = Sw[1:] - (vt * dt / dx) * (Fw[1:] - Fw[:-1]) # Set the left boundary condition. Sw[0] = bc_value # Record the time-step solution. Sw_hist.append(Sw.copy()) # Plot Sw over x # fig = pyplot.figure(figsize=(6.0, 4.0)) plt.xlabel(r&#39;$x$&#39;) plt.ylabel(r&#39;Sw&#39;) plt.grid() plt.plot(x, Sw0, label=&#39;Initial&#39;, color=&#39;C0&#39;, linestyle=&#39;--&#39;, linewidth=2) plt.plot(x, Sw, label=&#39;nt = {}&#39;.format(nt), color=&#39;C1&#39;, linestyle=&#39;-&#39;, linewidth=2) plt.xlim(0.0, L) plt.ylim(0, 1) plt.legend() plt.grid() Sw = np.arange(0.2, 0.9, 0.05) krw = np.array([0, .002, .02, .04, .07, .11, .15, .22, .3, .4, .5, .6, .7, .8]) kro = np.array([.6, .5, .4, .3, .23, .17, .12, .08, .05, .03, .02, .01, .005, 0]) # set parameters for initial condition L = 40 nx = 401 x = np.linspace(0.0, L, nx) Sw0 = np.full(nx, 0.2) Sw0[:15] = 1 plt.plot(x, Sw0) plt.xlim(min(x), max(x)) plt.xlabel(&#39;x&#39;); plt.ylabel(&#39;Sw&#39;) plt.title(&#39;Initial Condition&#39;, size=20) plt.show() # Set parameters for simulation nt = 70 # L = 4 sigma = 0.1 bc_value = Sw0[0] u_max = 1 muw = 0.5E-3 muo = 1E-3 q = 200 # m3/hr A = 30 # m2 poro = 0.24 # Simulation nt = [10, 500, 700, 900, 1200, 2000] plt.figure(figsize=(16,9)) for i in range(len(nt)): plt.subplot(3,2,i+1) buckley_leverett1d(nt[i], Sw0, L, nx, sigma, bc_value, muw, muo, q, A, poro, Sw, krw, kro) plt.show() "],["volumetrics.html", "12 Volumetrics 12.1 Calculating the Gas inplace by volumetric methods", " 12 Volumetrics 12.1 Calculating the Gas inplace by volumetric methods The standard cubic feet gas inplace, G is given by: \\[\\begin{equation} G = \\frac{43,560 V_{b} \\phi (1-S_{w})}{B_{g}} \\end{equation}\\] Contour Methods using trangulation mmethods # Tricontour (triangulation) method&quot; import matplotlib.tri as tri import matplotlib.pyplot as plt import matplotlib.cm as cm import numpy as np import pandas as pd import math from scipy.interpolate import griddata # data welldat = pd.read_csv(&#39;data/data_volumetrics.csv&#39;) x, y, z = welldat.x, welldat.y, welldat.z triang = tri.Triangulation(x, y) #----------------------------------------------------------------------------- # Refine data #----------------------------------------------------------------------------- refiner = tri.UniformTriRefiner(triang) tri_refi, z_test_refi = refiner.refine_field(z, subdiv=5) #----------------------------------------------------------------------------- # Plot the triangulation and the high-res iso-contours #----------------------------------------------------------------------------- plt.figure(figsize=(20, 20)) &lt;Figure size 2000x2000 with 0 Axes&gt; plt.gca().set_aspect(&#39;equal&#39;) plt.triplot(triang, lw=0.5, color=&#39;white&#39;) [&lt;matplotlib.lines.Line2D object at 0x16773a670&gt;, &lt;matplotlib.lines.Line2D object at 0x16773f4f0&gt;] levels = np.linspace(min(z)+10, max(z)-10, 10) ##contour range, divided by 10 levels cmap = cm.get_cmap(name=&#39;terrain&#39;, lut=None) &lt;string&gt;:1: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead. fig = plt.tricontourf(tri_refi, z_test_refi, levels=levels, cmap=cmap) fig = plt.tricontour(tri_refi, z_test_refi, levels=levels, colors=[&#39;0.25&#39;, &#39;0.5&#39;, &#39;0.5&#39;, &#39;0.5&#39;, &#39;0.5&#39;], linewidths=[1.0, 0.5, 0.5, 0.5, 0.5]) plt.plot(x, y, &#39;ko&#39;, ms=3) # plot the well points [&lt;matplotlib.lines.Line2D object at 0x16773aee0&gt;] plt.clabel(fig, fig.levels[::5], inline=1, fontsize=10) # give labels for contours, fig.levels[::x] controls the frequency of labels &lt;a list of 4 text.Text objects&gt; # lesser ::x, more populated by labels plt.title(&quot;Structure Map using Triangulation Method&quot;, pad=10, size=20) Text(0.5, 1.0, &#39;Structure Map using Triangulation Method&#39;) plt.show() "],["well-testing.html", "13 Well Testing 13.1 Fluid Flow Equations 13.2 Unsteady-State Flow 13.3 Basic Transient Flow Equation", " 13 Well Testing 13.1 Fluid Flow Equations Fluid flow equations are used to describe the behavior of fluids in reservoirs. These equations depend on variables such as flow type, fluid type, and reservoir conditions. By combining the conservation of mass equation, Darcy’s law, and equations of state, we derive the necessary flow equations. 13.1.1 Darcy’s Law Darcy’s law is the fundamental equation of fluid motion in porous media. It states that the velocity of a homogeneous fluid is proportional to the pressure gradient and inversely proportional to fluid viscosity. 13.1.1.1 Linear Flow: \\[ v = \\frac{q}{A} = -\\frac{k}{\\mu} \\frac{\\partial p}{\\partial x} \\] Where: - \\(v\\): Apparent velocity (cm/s) - \\(q\\): Volumetric flow rate (cm³/s) - \\(A\\): Cross-sectional area (cm²) - \\(k\\): Permeability (Darcies) - \\(\\mu\\): Viscosity (cP) - \\(\\frac{\\partial p}{\\partial x}\\): Pressure gradient (atm/cm) 13.1.1.2 Radial Flow: For radial systems, Darcy’s law is expressed as: \\[ v = \\frac{q}{A_r} = \\frac{k}{\\mu} \\frac{\\partial p}{\\partial r} \\] Where: - \\(A_r = 2 \\pi r h\\): Cross-sectional area for radial flow (cm²) - \\(r\\): Radial distance (cm) 13.1.1.3 Steady-State Flow: In steady-state conditions, the pressure does not vary with time: \\[ \\frac{\\partial p}{\\partial t} = 0 \\] For incompressible fluids in a linear system: \\[ q = \\frac{k A (p_1 - p_2)}{\\mu L} \\] In field units: \\[ q = 0.001127 \\cdot \\frac{k A (p_1 - p_2)}{\\mu L} \\] ### Python Code: Darcy’s Law for Steady-State Flow def darcy_flow_rate(permeability, area, pressure_difference, viscosity, length): &quot;&quot;&quot; Calculate flow rate using Darcy&#39;s law. Parameters: permeability (float): Permeability in md. area (float): Cross-sectional area in ft². pressure_difference (float): Pressure difference in psi. viscosity (float): Fluid viscosity in cp. length (float): Length of the reservoir in ft. Returns: float: Flow rate in bbl/day. &quot;&quot;&quot; conversion_factor = 0.001127 # Field unit conversion factor for Darcy&#39;s law return conversion_factor * permeability * area * pressure_difference / (viscosity * length) # Example Usage permeability = 100 # md area = 20 * 300 # Cross-sectional area (ft²) pressure_difference = 2000 - 1990 # psi viscosity = 2 # cp length = 2000 # ft flow_rate = darcy_flow_rate(permeability, area, pressure_difference, viscosity, length) print(f&quot;Flow Rate: {flow_rate:.2f} bbl/day&quot;) Flow Rate: 1.69 bbl/day 13.1.2 Linear Flow of Slightly Compressible Fluids For slightly compressible fluids, the relationship between pressure and volume is given by: \\[ V = V_{ref} \\cdot \\exp\\left(c \\cdot (p_{ref} - p)\\right) \\] The flow rate, adjusted for compressibility, can be written as: \\[ q = q_{ref} \\cdot \\left[1 + c \\cdot (p_{ref} - p)\\right] \\] Substituting this into Darcy’s law for linear flow: \\[ q_{ref} = \\frac{0.001127 \\cdot k \\cdot A}{\\mu \\cdot c \\cdot L} \\cdot \\ln\\left(\\frac{1 + c \\cdot (p_{ref} - p_2)}{1 + c \\cdot (p_{ref} - p_1)}\\right) \\] Where: - \\(q_{ref}\\): Flow rate at reference pressure (bbl/day) - \\(A\\): Cross-sectional area (ft²) - \\(L\\): Reservoir length (ft) - \\(k\\): Permeability (md) - \\(\\mu\\): Viscosity (cp) - \\(c\\): Compressibility coefficient (1/psi) - \\(p_1\\): Upstream pressure (psi) - \\(p_2\\): Downstream pressure (psi) - \\(p_{ref}\\): Reference pressure (psi) ### Python Code: Linear Flow of Slightly Compressible Fluids import math def linear_flow_compressible(q_ref, permeability, area, viscosity, compressibility, length, p1, p2, p_ref): &quot;&quot;&quot; Calculate the flow rate for slightly compressible fluids in a linear system. Parameters: q_ref (float): Flow rate at reference pressure (bbl/day). permeability (float): Permeability in md. area (float): Cross-sectional area in ft². viscosity (float): Fluid viscosity in cp. compressibility (float): Compressibility coefficient (1/psi). length (float): Length of the reservoir in ft. p1 (float): Upstream pressure in psi. p2 (float): Downstream pressure in psi. p_ref (float): Reference pressure in psi. Returns: float: Flow rate at the given pressures in bbl/day. &quot;&quot;&quot; numerator = 0.001127 * permeability * area denominator = viscosity * compressibility * length ln_term = math.log((1 + compressibility * (p_ref - p2)) / (1 + compressibility * (p_ref - p1))) return numerator / denominator * ln_term # Example Usage permeability = 100 # md area = 6000 # ft² (20 ft x 300 ft) viscosity = 2 # cp compressibility = 2e-5 # 1/psi length = 2000 # ft p1 = 2000 # psi p2 = 1990 # psi p_ref = 2000 # Reference pressure in psi flow_rate = linear_flow_compressible( q_ref=None, # Reference flow rate (not needed here) permeability=permeability, area=area, viscosity=viscosity, compressibility=compressibility, length=length, p1=p1, p2=p2, p_ref=p_ref ) print(f&quot;Flow Rate for Slightly Compressible Fluid: {flow_rate:.2f} bbl/day&quot;) Flow Rate for Slightly Compressible Fluid: 1.69 bbl/day 13.1.3 Linear Flow of Compressible Fluids (Gases) For compressible fluids such as gases, the flow rate equation is derived by incorporating the gas compressibility factor (\\(Z\\)) and gas viscosity (\\(\\mu_g\\)) into Darcy’s law. This requires integrating the governing equations over the pressure range. 13.1.3.1 Derivation of the Gas Flow Rate Equation Real Gas Law: The real gas law relates the pressure, volume, and temperature of a gas: \\[ p \\cdot V = n \\cdot Z \\cdot R \\cdot T \\] Where: \\(p\\): Pressure (psi) \\(V\\): Volume (ft³) \\(n\\): Moles of gas \\(Z\\): Gas compressibility factor (dimensionless) \\(R\\): Gas constant (10.73 ft³·psi/°R·lb-mol) \\(T\\): Temperature (°R) Darcy’s Law for Radial Flow: In steady-state conditions: \\[ q = \\frac{k}{\\mu_g} \\cdot \\frac{2 \\pi r h}{\\ln(r_e / r_w)} \\cdot \\frac{\\partial p}{\\partial r} \\] Flow Rate at Standard Conditions: Combining Darcy’s law and the real gas law, the gas flow rate at standard conditions (\\(Q_{sc}\\)) becomes: \\[ Q_{sc} = \\frac{1422 \\cdot k \\cdot h \\cdot T \\cdot (p_e^2 - p_w^2)}{Z \\cdot \\mu_g \\cdot \\ln(r_e / r_w)} \\] Where: \\(Q_{sc}\\): Flow rate at standard conditions (Mscf/day) \\(k\\): Permeability (md) \\(h\\): Reservoir thickness (ft) \\(T\\): Reservoir temperature (°R) \\(p_e, p_w\\): External and wellbore pressures (psi) \\(Z\\): Gas compressibility factor (dimensionless) \\(\\mu_g\\): Gas viscosity (cp) \\(r_e, r_w\\): Drainage and wellbore radii (ft) ### Python Code: Radial Flow of Compressible Gases import math def radial_flow_gas(permeability, thickness, temperature, external_pressure, wellbore_pressure, viscosity, compressibility_factor, drainage_radius, wellbore_radius): &quot;&quot;&quot; Calculate radial flow rate for compressible gases. Parameters: permeability (float): Permeability in md. thickness (float): Reservoir thickness in ft. temperature (float): Reservoir temperature in °R. external_pressure (float): External pressure in psi. wellbore_pressure (float): Wellbore pressure in psi. viscosity (float): Gas viscosity in cp. compressibility_factor (float): Gas compressibility factor (Z). drainage_radius (float): Drainage radius in ft. wellbore_radius (float): Wellbore radius in ft. Returns: float: Gas flow rate at standard conditions (Mscf/day). &quot;&quot;&quot; conversion_factor = 1422 # Field unit conversion factor for gas flow numerator = permeability * thickness * temperature * (external_pressure**2 - wellbore_pressure**2) denominator = compressibility_factor * viscosity * math.log(drainage_radius / wellbore_radius) return numerator / (conversion_factor * denominator) # Example Usage permeability = 100 # md thickness = 30 # ft temperature = 520 # °R external_pressure = 2500 # psi wellbore_pressure = 1500 # psi viscosity = 0.02 # cp compressibility_factor = 0.8 # Z-factor drainage_radius = 1000 # ft wellbore_radius = 0.33 # ft flow_rate = radial_flow_gas( permeability, thickness, temperature, external_pressure, wellbore_pressure, viscosity, compressibility_factor, drainage_radius, wellbore_radius ) print(f&quot;Gas Flow Rate (Radial): {flow_rate:.2f} Mscf/day&quot;) 13.2 Unsteady-State Flow Unsteady-state flow, also known as transient flow, occurs when the pressure in the reservoir changes with time. Unlike steady-state or pseudosteady-state conditions, the pressure distribution in the reservoir is time-dependent. 13.2.0.1 Governing Equation for Unsteady-State Flow The governing equation for fluid flow in porous media is derived by combining the continuity equation, Darcy’s law, and fluid compressibility. Continuity Equation: The conservation of mass for a compressible fluid in a porous medium is given as: \\[ \\frac{\\partial}{\\partial t} \\left( \\phi \\rho \\right) + \\nabla \\cdot (\\rho \\mathbf{v}) = 0 \\] Where: \\(\\phi\\): Porosity (fraction) \\(\\rho\\): Fluid density (lb/ft³) \\(\\mathbf{v}\\): Velocity vector (ft/day) Darcy’s Law: Substituting Darcy’s law for flow velocity: \\[ \\mathbf{v} = -\\frac{k}{\\mu} \\nabla p \\] Fluid Compressibility: For slightly compressible fluids, density changes with pressure as: \\[ \\rho = \\rho_0 \\exp(c \\cdot (p - p_0)) \\] Radial Unsteady-State Flow: Combining the above relationships and simplifying for radial flow, the governing equation becomes: \\[ \\frac{\\partial p}{\\partial t} = \\frac{1}{r} \\frac{\\partial}{\\partial r} \\left( r \\frac{\\partial p}{\\partial r} \\right) \\] This is the diffusivity equation, describing pressure propagation in porous media. 13.2.1 Solutions for Unsteady-State Flow Infinite Reservoir: For a well in an infinite reservoir, the solution to the diffusivity equation is: \\[ p(r, t) = p_i - \\frac{q \\mu}{4 \\pi k h} \\cdot \\ln\\left(\\frac{4 k t}{\\phi \\mu c r^2}\\right) \\] Where: \\(p(r, t)\\): Pressure at distance \\(r\\) and time \\(t\\) (psi) \\(p_i\\): Initial reservoir pressure (psi) \\(q\\): Flow rate (bbl/day) \\(k\\): Permeability (md) \\(h\\): Reservoir thickness (ft) \\(\\phi\\): Porosity (fraction) \\(\\mu\\): Fluid viscosity (cp) \\(c\\): Compressibility coefficient (1/psi) \\(t\\): Time (days) \\(r\\): Radial distance (ft) Semi-Infinite Reservoir with Wellbore Storage: Incorporating wellbore storage effects: \\[ p(r, t) = p_i - \\frac{q \\mu}{4 \\pi k h} \\cdot E_i \\left( \\frac{r^2 \\phi \\mu c}{4 k t} \\right) \\] Where \\(E_i\\) is the exponential integral function. ### Python Code: Pressure Distribution for Unsteady-State Flow import math def unsteady_state_pressure(initial_pressure, flow_rate, viscosity, permeability, thickness, time, porosity, compressibility, radius): &quot;&quot;&quot; Calculate pressure at a given radius and time during unsteady-state flow. Parameters: initial_pressure (float): Initial reservoir pressure (psi). flow_rate (float): Flow rate (bbl/day). viscosity (float): Fluid viscosity (cp). permeability (float): Permeability (md). thickness (float): Reservoir thickness (ft). time (float): Time since production started (days). porosity (float): Porosity (fraction). compressibility (float): Compressibility coefficient (1/psi). radius (float): Radial distance from the well (ft). Returns: float: Pressure at the given radius and time (psi). &quot;&quot;&quot; term1 = (4 * permeability * time) / (porosity * viscosity * compressibility * radius**2) pressure_drop = (flow_rate * viscosity) / (4 * math.pi * permeability * thickness) * math.log(term1) return initial_pressure - pressure_drop # Example Usage initial_pressure = 3000 # psi flow_rate = 500 # bbl/day viscosity = 1 # cp permeability = 50 # md thickness = 20 # ft time = 10 # days porosity = 0.2 # fraction compressibility = 1e-5 # 1/psi radius = 500 # ft pressure = unsteady_state_pressure(initial_pressure, flow_rate, viscosity, permeability, thickness, time, porosity, compressibility, radius) print(f&quot;Pressure at radius {radius} ft and time {time} days: {pressure:.2f} psi&quot;) 13.3 Basic Transient Flow Equation The Basic Transient Flow Equation governs the behavior of unsteady-state flow in porous media. It is derived by combining fundamental principles of fluid dynamics: conservation of mass, Darcy’s law, and fluid compressibility. 13.3.1 Derivation of flow equation 13.3.1.1 Step 1: Conservation of Mass The continuity equation expresses the conservation of mass for a compressible fluid in porous media: \\[ \\frac{\\partial}{\\partial t} \\left( \\phi \\rho \\right) + \\nabla \\cdot (\\rho \\mathbf{v}) = 0 \\] Where: - \\(\\phi\\): Porosity (fraction) - \\(\\rho\\): Fluid density (lb/ft³) - \\(\\mathbf{v}\\): Velocity vector (ft/day) - \\(t\\): Time (days) For radial flow, this becomes: \\[ \\frac{\\partial}{\\partial t} \\left( \\phi \\rho \\right) + \\frac{1}{r} \\frac{\\partial}{\\partial r} (r \\rho v) = 0 \\] 13.3.1.2 Step 2: Substituting Darcy’s Law Darcy’s law for radial flow is: \\[ v = -\\frac{k}{\\mu} \\frac{\\partial p}{\\partial r} \\] Substituting \\(v\\) into the continuity equation: \\[ \\frac{\\partial}{\\partial t} \\left( \\phi \\rho \\right) - \\frac{1}{r} \\frac{\\partial}{\\partial r} \\left( r \\rho \\frac{k}{\\mu} \\frac{\\partial p}{\\partial r} \\right) = 0 \\] 13.3.1.3 Step 3: Slightly Compressible Fluids For slightly compressible fluids, density changes with pressure as: \\[ \\rho = \\rho_0 \\exp(c \\cdot (p - p_0)) \\] Where: - \\(\\rho_0\\): Reference density (lb/ft³) - \\(p_0\\): Reference pressure (psi) - \\(c\\): Compressibility coefficient (1/psi) Using a first-order approximation for \\(c \\ll 1\\): \\[ \\rho \\approx \\rho_0 \\left( 1 + c \\cdot (p - p_0) \\right) \\] The time derivative of \\(\\rho\\) becomes: \\[ \\frac{\\partial \\rho}{\\partial t} = \\rho_0 c \\frac{\\partial p}{\\partial t} \\] 13.3.1.4 Step 4: Substituting Fluid Compressibility Substituting the compressibility relationship into the continuity equation: \\[ \\phi \\rho_0 c \\frac{\\partial p}{\\partial t} = \\frac{k}{\\mu} \\frac{1}{r} \\frac{\\partial}{\\partial r} \\left( r \\frac{\\partial p}{\\partial r} \\right) \\] 13.3.1.5 Step 5: Simplifying to the Diffusivity Equation Dividing through by \\(\\phi \\rho_0 c\\): \\[ \\frac{\\partial p}{\\partial t} = \\frac{k}{\\phi \\mu c} \\frac{1}{r} \\frac{\\partial}{\\partial r} \\left( r \\frac{\\partial p}{\\partial r} \\right) \\] Define the diffusivity constant as: \\[ \\eta = \\frac{k}{\\phi \\mu c} \\] The equation simplifies to: \\[ \\frac{\\partial p}{\\partial t} = \\eta \\frac{1}{r} \\frac{\\partial}{\\partial r} \\left( r \\frac{\\partial p}{\\partial r} \\right) \\] This is the radial diffusivity equation, governing transient flow in porous media. 13.3.1.6 Step 6: Initial and Boundary Conditions To solve the diffusivity equation, initial and boundary conditions must be defined: Initial Condition: At \\(t = 0\\), the reservoir pressure is uniform: \\[ p(r, 0) = p_i \\] Outer Boundary Condition: For an infinite reservoir, the pressure remains constant at large distances: \\[ \\lim_{r \\to \\infty} p(r, t) = p_i \\] Inner Boundary Condition: At the wellbore (\\(r = r_w\\)), the pressure depends on the flow rate: \\[ q = -2 \\pi r_w h \\frac{k}{\\mu} \\frac{\\partial p}{\\partial r} \\bigg|_{r = r_w} \\] 13.3.1.7 Step 7: Dimensionless Form of the Diffusivity Equation Introducing dimensionless variables: \\[ p_D = \\frac{p_i - p}{p_i - p_w}, \\quad r_D = \\frac{r}{r_w}, \\quad t_D = \\frac{\\eta t}{r_w^2} \\] The diffusivity equation becomes: \\[ \\frac{\\partial p_D}{\\partial t_D} = \\frac{1}{r_D} \\frac{\\partial}{\\partial r_D} \\left( r_D \\frac{\\partial p_D}{\\partial r_D} \\right) \\] 13.3.1.8 Step 8: Analytical Solution for Constant Flow Rate For a constant flow rate \\(q\\) at the wellbore, the pressure at any distance \\(r\\) and time \\(t\\) is: \\[ p(r, t) = p_i - \\frac{q \\mu}{4 \\pi k h} \\cdot \\ln\\left( \\frac{4 \\eta t}{r^2} \\right) \\] At the wellbore (\\(r = r_w\\)): \\[ p_w = p_i - \\frac{q \\mu}{4 \\pi k h} \\cdot \\ln\\left( \\frac{4 \\eta t}{r_w^2} \\right) \\] 13.3.1.9 Final Equation: Substituting the diffusivity constant (\\(\\eta = \\frac{k}{\\phi \\mu c}\\)) into the solution: \\[ p_w = p_i - \\frac{q \\mu}{4 \\pi k h} \\cdot \\ln\\left( \\frac{4 k t}{\\phi \\mu c r_w^2} \\right) \\] This is equation is representing the pressure at the wellbore during transient flow in a slightly compressible fluid. 13.3.2 Radial Flow of Slightly Compressible Fluids Radial flow of slightly compressible fluids involves deriving the governing equations by incorporating the compressibility effects into the radial flow model. The fluid is assumed to follow the slightly compressible behavior, making it suitable for real-world reservoir applications. 13.3.2.1 Step 1: Governing Diffusivity Equation The governing equation for radial flow in porous media is: \\[ \\frac{\\partial p}{\\partial t} = \\eta \\frac{1}{r} \\frac{\\partial}{\\partial r} \\left( r \\frac{\\partial p}{\\partial r} \\right) \\] Where: - \\(p\\): Pressure (psi) - \\(t\\): Time (days) - \\(r\\): Radial distance from the wellbore (ft) - \\(\\eta = \\frac{k}{\\phi \\mu c}\\): Diffusivity constant 13.3.2.2 Step 2: Dimensionless Variables To simplify the solution, introduce dimensionless variables: 1. Dimensionless Pressure: \\[ p_D = \\frac{p_i - p}{p_i - p_w} \\] Where: - \\(p_i\\): Initial reservoir pressure (psi) - \\(p_w\\): Wellbore pressure (psi) Dimensionless Radius: \\[ r_D = \\frac{r}{r_w} \\] Where: \\(r_w\\): Wellbore radius (ft) Dimensionless Time: \\[ t_D = \\frac{\\eta t}{r_w^2} \\] Substituting these into the diffusivity equation: \\[ \\frac{\\partial p_D}{\\partial t_D} = \\frac{1}{r_D} \\frac{\\partial}{\\partial r_D} \\left( r_D \\frac{\\partial p_D}{\\partial r_D} \\right) \\] 13.3.2.3 Step 3: Analytical Solution for Constant Flow Rate For a constant flow rate (\\(q\\)) at the wellbore, the solution to the diffusivity equation in an infinite reservoir is: \\[ p_D(r_D, t_D) = \\frac{q \\mu}{4 \\pi k h} \\cdot E_i \\left( \\frac{r_D^2}{4 t_D} \\right) \\] Where: - \\(E_i(x)\\): Exponential integral function. At the wellbore (\\(r_D = 1\\)), the pressure becomes: \\[ p_D(1, t_D) = \\frac{q \\mu}{4 \\pi k h} \\cdot E_i \\left( \\frac{1}{4 t_D} \\right) \\] 13.3.2.4 Step 4: Infinite Reservoir Assumptions Using the properties of the exponential integral function: 1. For small arguments (\\(x \\to 0\\)): \\[ E_i(x) \\approx -\\ln(x) - 0.5772 \\] Substituting \\(x = \\frac{1}{4 t_D}\\), we have: \\[ p_D(1, t_D) = \\frac{q \\mu}{4 \\pi k h} \\cdot \\left( -\\ln(4 t_D) - 0.5772 \\right) \\] 13.3.2.5 Step 5: Pressure at the Wellbore Returning to dimensional variables, the wellbore pressure is: \\[ p_w = p_i - \\frac{q \\mu}{4 \\pi k h} \\cdot \\left( -\\ln \\left( \\frac{4 k t}{\\phi \\mu c r_w^2} \\right) - 0.5772 \\right) \\] Simplifying: \\[ p_w = p_i - \\frac{q \\mu}{4 \\pi k h} \\cdot \\ln \\left( \\frac{4 k t}{\\phi \\mu c r_w^2} \\right) - \\frac{q \\mu}{4 \\pi k h} \\cdot 0.5772 \\] 13.3.2.6 Final Equation: Converting the logarithmic term to base-10 for field units: \\[ p_w = p_i - \\frac{70.6 \\cdot q \\cdot \\mu}{k \\cdot h} \\cdot \\left( \\log_{10} \\left( \\frac{4 k t}{\\phi \\mu c r_w^2} \\right) + 0.87 \\right) \\] This is equation describes the pressure at the wellbore during transient flow of slightly compressible fluids. To obtain a solution to the diffusivity equation, it is necessary to specify an initial condition and two boundary conditions. The initial condition simply states that the reservoir is at a uniform pressure when production begins. This is true in almost all the cases. The two boundary conditions require that the well is producing at a constant production rate (or constant flowing bottom hole pressure) and the reservoir behaves as if it were infinite in size. "],["water-influx.html", "14 Water Influx 14.1 Classification of Aquifers 14.2 Recognition of Natural Water Influx 14.3 Water Influx Models", " 14 Water Influx Water influx describes the encroachment of water into a hydrocarbon reservoir due to pressure differentials. This chapter explores various water influx mechanisms, aquifer classifications, and computational models for predicting and managing water influx in reservoir engineering. 14.1 Classification of Aquifers 14.1.1 Degree of Pressure Maintenance Active water drive Partial water drive Limited water drive 14.1.2 Outer Boundary Conditions Infinite system Finite system 14.1.3 Flow Regimes Steady-state Semi (pseudo) steady-state Unsteady-state 14.1.4 Flow Geometries Edge-water drive Bottom-water drive Linear-water drive 14.2 Recognition of Natural Water Influx Identifying water influx using reservoir performance trends Calculating barrels withdrawn per psi change in reservoir pressure Recognizing the effects of undeveloped reservoir areas 14.3 Water Influx Models 14.3.1 The Pot Aquifer Model The Pot Aquifer Model is the simplest representation of water influx. It assumes that the aquifer acts like a storage tank (or pot) and provides water influx based solely on the pressure difference between the aquifer and the reservoir. This model is widely used for reservoirs with limited water drive or where the aquifer size is relatively small compared to the reservoir. 14.3.1.1 Assumptions of the Pot Aquifer Model The aquifer behaves as a single unit with uniform pressure. Water influx is proportional to the pressure difference between the aquifer and the reservoir. No time delay is considered for water flow within the aquifer. Compressibility of water and pore volume are constant. 14.3.1.2 Governing Equation The cumulative water influx (\\(W_e\\)) is proportional to the pressure drop in the reservoir: \\[ W_e = c_w \\cdot V_a \\cdot (p_a - p) \\] Where: - \\(W_e\\): Cumulative water influx (bbl) - \\(c_w\\): Water and pore compressibility (1/psi) - \\(V_a\\): Aquifer pore volume (bbl) - \\(p_a\\): Initial aquifer pressure (psi) - \\(p\\): Current reservoir pressure (psi) 14.3.1.3 Derivation of the Governing Equation Volume Change: The volume of water entering the reservoir is due to the compression of water and the expansion of pore space: \\[ \\Delta V = c_w \\cdot V_a \\cdot \\Delta p \\] Where: \\(\\Delta V\\): Volume of water influx (bbl) \\(\\Delta p = p_a - p\\): Pressure drop (psi) Cumulative Water Influx: Integrating the volume change over time gives the cumulative water influx: \\[ W_e = c_w \\cdot V_a \\cdot (p_a - p) \\] 14.3.1.4 Practical Applications Small Aquifers: This model is best suited for reservoirs with small or limited aquifers where pressure gradients within the aquifer can be neglected. Initial Estimates: The Pot Aquifer Model is often used for quick initial estimates of water influx before switching to more complex models. # Example Python Code: Pot Aquifer Model def pot_aquifer_water_influx(c_w, V_a, p_a, p): &quot;&quot;&quot; Calculate cumulative water influx using the Pot Aquifer Model. Parameters: c_w (float): Water and pore compressibility (1/psi). V_a (float): Aquifer pore volume (bbl). p_a (float): Initial aquifer pressure (psi). p (float): Current reservoir pressure (psi). Returns: float: Cumulative water influx (bbl). &quot;&quot;&quot; return c_w * V_a * (p_a - p) # Given parameters c_w = 3e-6 # 1/psi V_a = 2e7 # bbl p_a = 3000 # psi p = 2500 # psi # Calculate cumulative water influx W_e = pot_aquifer_water_influx(c_w, V_a, p_a, p) print(f&quot;Cumulative Water Influx (W_e): {W_e:.2f} bbl&quot;) Cumulative Water Influx (W_e): 30000.00 bbl 14.3.2 Schilthuis Steady-State Model The Schilthuis Steady-State Model assumes that water influx occurs under steady-state flow conditions, where the flow rate is constant, and the pressure gradient across the aquifer does not change with time. This model is widely used in cases where the aquifer quickly responds to pressure changes in the reservoir, maintaining steady flow. 14.3.2.1 Assumptions of the Schilthuis Steady-State Model The aquifer behaves as an infinite system with no boundary effects. Steady-state flow conditions exist, meaning the pressure gradient across the aquifer remains constant. Water influx is directly proportional to the pressure difference between the aquifer and the reservoir. 14.3.2.2 Governing Equation The rate of water influx (\\(W_e\\)) is given by: \\[ W_e = J \\cdot (p_a - p) \\] Where: - \\(W_e\\): Water influx rate (bbl/day) - \\(J\\): Productivity index of the aquifer (bbl/day/psi) - \\(p_a\\): Average aquifer pressure (psi) - \\(p\\): Reservoir pressure (psi) The cumulative water influx over time is: \\[ W_e(t) = J \\cdot \\int_0^t (p_a - p) \\, dt \\] 14.3.2.3 Derivation of the Steady-State Flow Equation Darcy’s Law: For radial flow in a porous medium: \\[ q = \\frac{2 \\pi k h (p_a - p)}{\\mu \\ln(r_e / r_w)} \\] Aquifer Productivity Index (\\(J\\)): Define the aquifer productivity index as: \\[ J = \\frac{2 \\pi k h}{\\mu \\ln(r_e / r_w)} \\] Substituting this into Darcy’s law: \\[ W_e = J \\cdot (p_a - p) \\] Cumulative Water Influx: To find the cumulative water influx over time, integrate the rate of water influx: \\[ W_e(t) = \\int_0^t W_e \\, dt = J \\cdot \\int_0^t (p_a - p) \\, dt \\] 14.3.2.4 Applications of the Schilthuis Model Aquifers with Fast Response: Suitable for aquifers where steady-state flow conditions are quickly established. Pressure Maintenance: Used to estimate the water influx required to maintain reservoir pressure during production. 14.3.3 Example Calculation Suppose the following parameters: - \\(J = 100\\) bbl/day/psi - \\(p_a = 3000\\) psi - \\(p = 2500\\) psi - Time of interest: \\(t = 10\\) days The water influx rate is: \\[ W_e = J \\cdot (p_a - p) = 100 \\cdot (3000 - 2500) = 50000 \\, \\text{bbl/day} \\] Cumulative water influx over 10 days is: \\[ W_e(t) = W_e \\cdot t = 50000 \\cdot 10 = 500000 \\, \\text{bbl} \\] 14.3.4 Python Code: Schilthuis Steady-State Model def schilthuis_water_influx_rate(J, p_a, p): &quot;&quot;&quot; Calculate the water influx rate using the Schilthuis Steady-State Model. Parameters: J (float): Productivity index of the aquifer (bbl/day/psi). p_a (float): Average aquifer pressure (psi). p (float): Reservoir pressure (psi). Returns: float: Water influx rate (bbl/day). &quot;&quot;&quot; return J * (p_a - p) def cumulative_water_influx(W_e, time): &quot;&quot;&quot; Calculate the cumulative water influx over a given time period. Parameters: W_e (float): Water influx rate (bbl/day). time (float): Time period (days). Returns: float: Cumulative water influx (bbl). &quot;&quot;&quot; return W_e * time # Given parameters J = 100 # bbl/day/psi p_a = 3000 # psi p = 2500 # psi time = 10 # days # Calculate water influx rate and cumulative water influx W_e = schilthuis_water_influx_rate(J, p_a, p) W_e_cumulative = cumulative_water_influx(W_e, time) print(f&quot;Water Influx Rate (W_e): {W_e:.2f} bbl/day&quot;) Water Influx Rate (W_e): 50000.00 bbl/day print(f&quot;Cumulative Water Influx (W_e(t)): {W_e_cumulative:.2f} bbl&quot;) Cumulative Water Influx (W_e(t)): 500000.00 bbl Solving one example: Example: The aquifer is under a steady-state flowing condition with an estimated water influx constant of 130 bbl/day/psi. Given the initial reservoir pressure is 3500 psi, calculate the cumulative water influx after 100, 200, 300, and 400 days using the steady-state model. time (days) p (psi) pi-p (psi) 0 3500 0 100 3450 50 200 3410 90 300 3380 120 400 3340 160 the python code to solve the given problem is as follows: def calculate_water_influx(c, pressure_data, t_intervals, initial_pressure): &quot;&quot;&quot; Calculate cumulative water influx using the Schilthuis steady-state model. Parameters: c (float): Water influx constant (bbl/day/psi). pressure_data (list): Reservoir pressures at different times (psi). t_intervals (list): Time intervals corresponding to pressures (days). initial_pressure (float): Initial reservoir pressure (psi). Returns: list: Cumulative water influx values at each time step (bbl). &quot;&quot;&quot; cumulative_influx = [] previous_influx = 0 delta_pressure = [] delta_time = [] for i in range(len(t_intervals)): delta_p = (initial_pressure - pressure_data[i]) delta_t = t_intervals[i] - (t_intervals[i - 1] if i &gt; 0 else 0) delta_pressure.append(delta_p) delta_time.append(delta_t) for j in range(len(delta_pressure)-2, len(delta_pressure)): water_influx = c * delta_pressure[j] * delta_time[j]/2 previous_influx += water_influx cumulative_influx.append(previous_influx) return cumulative_influx # Given data c = 130 # Water influx constant (bbl/day/psi) initial_pressure = 3500 # psi pressure_data = [3500, 3450, 3410, 3380, 3340] # psi t_intervals = [0, 100, 200, 300, 400] # days # Calculate cumulative water influx cumulative_influx = calculate_water_influx(c, pressure_data, t_intervals, initial_pressure) # Display results for t, influx in zip(t_intervals, cumulative_influx): print(&quot;_&quot;*50) print(f&quot;Day {t}: Cumulative Water Influx = {influx:.2f} bbl&quot;) __________________________________________________ Day 0: Cumulative Water Influx = 0.00 bbl __________________________________________________ Day 100: Cumulative Water Influx = 325000.00 bbl __________________________________________________ Day 200: Cumulative Water Influx = 1235000.00 bbl __________________________________________________ Day 300: Cumulative Water Influx = 2600000.00 bbl __________________________________________________ Day 400: Cumulative Water Influx = 4420000.00 bbl 14.3.5 Hurst Modified Steady-State Model The Hurst Modified Steady-State Model refines the Schilthuis steady-state model by considering the time-dependent behavior of finite aquifers. This model accounts for the fact that steady-state conditions are not immediately established and that aquifers exhibit transient behavior before reaching equilibrium. 14.3.5.1 Assumptions of the Hurst Modified Model The aquifer is finite and bounded, resulting in time-dependent water influx. The pressure gradient across the aquifer changes with time until steady-state flow is established. The aquifer eventually reaches steady-state conditions if sufficient time is allowed. 14.3.5.2 Governing Equation The cumulative water influx (\\(W_e(t)\\)) is expressed as: \\[ W_e(t) = W_e^* \\cdot \\left(1 - e^{-\\beta t}\\right) \\] Where: - \\(W_e(t)\\): Cumulative water influx at time \\(t\\) (bbl) - \\(W_e^*\\): Maximum (steady-state) water influx (bbl) - \\(\\beta\\): Time constant (1/day) - \\(t\\): Time (days) 14.3.5.3 Derivation of the Governing Equation Steady-State Maximum Water Influx: Under steady-state conditions, the water influx rate is constant and reaches a maximum value: \\[ W_e^* = J \\cdot (p_a - p) \\] Where \\(J\\) is the aquifer productivity index. Time-Dependent Behavior: For a finite aquifer, the water influx rate increases over time as the pressure gradient propagates through the aquifer. This time dependency is modeled as: \\[ W_e(t) = W_e^* \\cdot \\left(1 - e^{-\\beta t}\\right) \\] The exponential term \\(\\left(1 - e^{-\\beta t}\\right)\\) accounts for the delayed establishment of steady-state conditions. Time Constant (\\(\\beta\\)): The time constant is defined as: \\[ \\beta = \\frac{k}{\\phi \\mu c \\cdot V_a} \\] Where: \\(k\\): Permeability (md) \\(\\phi\\): Porosity (fraction) \\(\\mu\\): Fluid viscosity (cp) \\(c\\): Total compressibility (1/psi) \\(V_a\\): Aquifer pore volume (bbl) 14.3.5.4 Applications of the Hurst Modified Model Finite Aquifers: This model is ideal for reservoirs with finite aquifers where boundary effects significantly influence water influx. Transient Behavior: Used to predict water influx during the early stages of production before steady-state conditions are established. 14.3.6 Example Calculation Suppose the following parameters: - \\(W_e^* = 100000\\) bbl - \\(\\beta = 0.005\\) 1/day - Time: \\(t = [0, 50, 100, 150, 200]\\) days The cumulative water influx at each time step can be calculated using: \\[ W_e(t) = W_e^* \\cdot \\left(1 - e^{-\\beta t}\\right) \\] 14.3.7 Python Code: Hurst Modified Steady-State Model import math def hurst_modified_water_influx(W_e_star, beta, times): &quot;&quot;&quot; Calculate cumulative water influx using the Hurst Modified Steady-State Equation. Parameters: W_e_star (float): Maximum steady-state water influx (bbl). beta (float): Time constant (1/day). times (list): List of time points (days). Returns: list: Cumulative water influx at each time point (bbl). &quot;&quot;&quot; return [W_e_star * (1 - math.exp(-beta * t)) for t in times] # Given parameters W_e_star = 100000 # bbl beta = 0.005 # 1/day times = [0, 50, 100, 150, 200] # days # Calculate cumulative water influx water_influx = hurst_modified_water_influx(W_e_star, beta, times) # Display results for t, W_e in zip(times, water_influx): print(f&quot;Day {t}: Cumulative Water Influx = {W_e:.2f} bbl&quot;) Day 0: Cumulative Water Influx = 0.00 bbl Day 50: Cumulative Water Influx = 22119.92 bbl Day 100: Cumulative Water Influx = 39346.93 bbl Day 150: Cumulative Water Influx = 52763.34 bbl Day 200: Cumulative Water Influx = 63212.06 bbl solving one more import math def hurst_cumulative_water_influx(time_intervals, delta_pressure, C, a): &quot;&quot;&quot; Calculate cumulative water influx using the Hurst equation. Parameters: time_intervals (list): List of time intervals (days). delta_pressure (list): Pressure drop values (psi) corresponding to time intervals. C (float): Coefficient of the Hurst equation. a (float): Aquifer parameter for time dependence. Returns: list: Cumulative water influx values (MMbbl) at each time step. &quot;&quot;&quot; cumulative_influx = [] total_influx = 0 for i in range(1, len(time_intervals)): t1, t2 = time_intervals[i - 1], time_intervals[i] dp1, dp2 = delta_pressure[i - 1], delta_pressure[i] ln_t1, ln_t2 = (0 if t1 ==0 else math.log(a * t1)), math.log(a * t2) avg_dp = (dp1 + dp2) / 2 delta_t = t2 - t1 # Incremental water influx using the Hurst equation delta_influx = C * avg_dp * delta_t / (ln_t2 - ln_t1) total_influx += delta_influx cumulative_influx.append(total_influx) return cumulative_influx # Given data time_intervals = [0, 182.5, 365.0, 547.5, 730.0, 912.5, 1095.0] # days delta_pressure = [0, 19, 84, 150, 246, 308, 377] # psi C = 50 # coefficient of the Hurst equation (MMbbl/psi) a = 0.064 # aquifer time-dependent parameter # Calculate cumulative water influx cumulative_influx = hurst_cumulative_water_influx(time_intervals, delta_pressure, C, a) # Display results print(&quot;Time (days) | Cumulative Water Influx (MMbbl)&quot;) Time (days) | Cumulative Water Influx (MMbbl) for t, influx in zip(time_intervals[1:], cumulative_influx): # Skip first time interval (t=0) print(f&quot;{t:&gt;10} | {influx:&gt;25.3f} MMbbl&quot;) 182.5 | 35269.245 MMbbl 365.0 | 713245.746 MMbbl 547.5 | 3346332.980 MMbbl 730.0 | 9626703.475 MMbbl 912.5 | 20954053.000 MMbbl 1095.0 | 38095813.717 MMbbl 14.3.8 van Everdingen and Hurst Unsteady-State Model Infinite aquifer Bounded aquifer 14.3.9 Dimensionless Water Influx Dimensionless time and radius Application of dimensionless water influx constants 14.3.10 Carter and Tracy Water Influx Model Simplified computation without superposition "],["material-balance.html", "15 Material Balance", " 15 Material Balance "],["fractional-flow.html", "16 Fractional Flow", " 16 Fractional Flow "],["pattern-floods.html", "17 Pattern Floods 17.1 Recovery Efficiency 17.2 Pattern Recovery 17.3 aa", " 17 Pattern Floods The effectiveness of a displacement process depends on many factors. These factors include reservoir and fluid characteristics that are beyond our control, such as depth, structure, and fluid type. Other factors that influence displacement efficiency can be controlled, however. They include the number and type of wells, well rates, and well locations. The distribution of wells is known as the well pattern. The impact of well pattern on displacement effectiveness is discussed after definitions of recovery efficiency are presented. 17.1 Recovery Efficiency Recovery efficiency is quantified by comparing initial and final volumes of fluid in place. It takes into account volumetric and displacement efficiency. The different aspects of recovery efficiency are defined and then combined to form overall recovery efficiency. Displacement efficiency accounts for the efficiency of recovering mobile hydrocarbon. To be specific, we define displacement efficiency for oil as the ratio of mobile oil to original oil in place at reservoir conditions \\[\\begin{equation} \\tag{17.1} E_{D} = \\frac{S_{oi} - S_{or}}{S_{oi}} \\end{equation}\\] Displacement efficiency is a measure of how effectively mobile hydrocarbons can be recovered. In addition to displacement efficiency, volumetric factors are needed to determine overall recovery efficiency. Areal and vertical sweep efficiencies are defined by \\[\\begin{equation} (\\#eq:ArialEfficency) E_{A} = \\frac{Sweep Area}{Total Area} \\\\ E_{V} = \\frac{Sweep Thickness}{Total Thickness} \\end{equation}\\] Reservoir flow models are useful tools for quantifying both swept area and swept thickness. The product of areal and vertical sweep efficiency is the volumetric sweep efficiency \\[\\begin{equation} \\tag{17.2} E_{vol} = E_{A}E_{V} \\end{equation}\\] Overall recovery efficiency must account for both volumetric and displacement effects. It is therefore defined as the product of volumetric sweep efficiency and displacement efficiency. Notice that each of the efficiency factors in recovery efficiency can be relatively large,, and yet recovery efficiency will be relatively small. For example, suppose the areal and vertical efficiencies are each 70% and displacement efficiency is 80%, the product of these efficiencies is approximately 39%. This means that even the reservoirs with the best recovery efficiency often have a substantial volume of unrecovered hydrocarbon remaining in the ground. The most important goal of improved recovery techniques is to recover this remaining resource 17.1.1 Patterns and Spacing The alignment of the injector-producer pair represents a linear displacement process. It is the simplest pattern involving injection and production wells. A variety of other patterns may be defined by alining Injector producer pairs. The ratio of the number of producing wells to the number of injection wells is shown in Table 7-1. The patterns depicted in Table 7-1 and Figure 7-1 are symmetric patterns that are especially effective for reservoirs with relatively small dip and large areal extent. The injectors and producers are generally interspersed. Other patterns in which injectors and producers are grouped together may be needed for reservoirs with significant dip. For example, a peripheral or flank injection pattern may be needed to effectively flood an anticlinal or monoclinal reservoir Table 17.1: Producer-to-Injector Ratios for Common Well Patterns Well Pattern Producer : Injector Ratio 1. Four-Spot 2 2. Five-Spot 1 3. Direct Line-drive 1 4. Staggered Line-drive 1 5. Seven-Spot 1/2 6 Nine- Spot 1/3 The location of injection wells depends on factors such as reservoir structure, injected fluid type, and displacement mechanism. For example, up structure gas injection can be an effective displacement process for producing a monoclinal reservoir containing oil. It relies on the movement of a gas-oil contact and the displacement of oil to down structure production wells. On the other hand, down structure peripheral injection of water can be used to displace oil to up structure producers in an anticlinal reservoir. In this case, down structure water injection is used to move the oil-water contact up structure and displace oil to up structure production wells. The same displacement concept applies to production of an anticlinal oil reservoir with strong aquifer support. In addition to reservoir geometry and displacement process, the well pattern depends on the distribution of existing production wells and the desired spacing of wells. Well spacing is an estimate of the area being drained by a production well. A reduction in well spacing requires an increase in the density of production wells. The density of production wells is the number of production wells in a specified area. Well density can be increased by drilling additional wells in the space between wells in a process called infill drilling. Infill drilling is an effective means of altering flow patterns and improving recovery efficiency, but can be more expensive than a fluid displacement process. The selection of a development plan depends on a comparison of the economics of alternative development concepts. Reservoir models are especially useful tools for performing these studies. 17.2 Pattern Recovery Optimum performance may be achieved with the patterns defined in the previous section by controlling the rates of injectors and producers. These calculations can be performed analytically if we assume the displacing and displaced fluids are in-compressible, the mobility ratio is one, and the reservoir has uniform properties. Values of injection rates for the three patterns. The calculation of analytical injection rates, even under a set of restrictive assumptions, provides a methodology for designing well patterns without using a reservoir simulator. More accurate estimates of injection rates under a less restrictive set of assumptions are obtained using reservoir simulators. For example, simulators have been used to correlate volumetric sweep efficiency with mobility ratio and permeability variation in a reservoir that is being subjected to a pattern flood. One measure of permeability variation is the Dykstra-Parsons coefficient of permeability variation. The Dykstra-Parsons coefficient can be estimated for a log-normal permeability distribution as \\[\\begin{equation} \\tag{17.3} V_{DP} = 1- exp\\Big( - \\sqrt {ln \\Big(\\frac{K_{A}}{K_{H}}\\Big)} \\Big) \\end{equation}\\] where \\[\\begin{equation} \\tag{17.4} K_{A} = \\frac{1}{n} \\displaystyle\\sum_{i=1}^{n} K_i \\\\ K_{H} = \\frac{1}{n} \\displaystyle\\sum_{i=1}^{n} \\frac{1}{K_i} \\end{equation}\\] The Dykstra-Parsons coefficient should be in the range 0 &lt; VDP &lt; 1. For a perfectly homogeneous reservoir, VDP = 0 because KA = KH. An increase in reservoir heterogeneity increases VDP. Typical values of the Dykstra-Parsons coefficient are in the range 0.4 &lt; VDP &lt; 0.9. import math as M # let&#39;s take the layer-wise permeability data of an arbitrary reservoir K = [365.0, 275.0, 165.0, 121.0, 73.0, 37.0, 19.0, 9.3, 3.5, 1.9] # md # Calculate KA KA = sum(K) / len(K) KH = sum([1/k for k in K])/len(K) VDP = 1- M.exp(-M.sqrt(M.log(KA/KH))) print(VDP) 17.3 aa "],["gas-and-water-coning.html", "18 Gas and Water Coning 18.1 Coning in Vertical wells 18.2 Coning in Horizontal wells", " 18 Gas and Water Coning Coning is a term used to describe the mechanism of upward movement of Water or downward movement of Gas into the producing well. 18.1 Coning in Vertical wells 18.1.1 Meyer-Garder Correlation In 1954 Meyer and Garder suggested following relation in Gas Oil Coning System import math #Sample Data Kh = 110 #md Kro = 0.85 # oil relative permeability po = 47.5 # lb/ft3 (oil Density) pg = 5.1 # lb/ft3 (gas Density) mu= 0.73 # cp (Oil viscosity) fvf = 1.1 # bbl/STB h = 40 #ft (oil column thickness) hp = 15 #ft (perforation interval) Dt = 25 # ft (depth of GOC from top of perforation) rw = 0.25 #ft (wellbore radius) re = 660 # ft (drainage radius) Qc = 0.0000246*(po-pg)*(Kh*Kro/(mu*fvf))*(h**2-(h-Dt)**2)/math.log(re/rw) print(f&#39;Critical Oil rate = {Qc} STB/day&#39;) Critical Oil rate = 21.19601914346511 STB/day for Oil water system: #same data as above example pw = 63.76 # lb/ft3 (water Density) Qc = 0.0000246*(pw-po)*(Kh*Kro/(mu*fvf))*(h**2-hp**2)/math.log(re/rw) print(f&#39;Critical Oil rate = {Qc} STB/day&#39;) Critical Oil rate = 8.12847337907412 STB/day for gas Oil water system: #same data as above example h = 65 #ft (oil column thickness) Qc = 0.0000246*(Kh*Kro/(mu*fvf))*((h**2-hp**2)/math.log(re/rw))*((pw-po)*((po-pg)/(pw-pg))**2+((po-pg)*(1-(po-pg)/(pw-pg))**2)) print(f&#39;Critical Oil rate = {Qc} STB/day&#39;) Critical Oil rate = 17.091889596019843 STB/day 18.2 Coning in Horizontal wells "],["working-with-las-files.html", "19 working with Las files 19.1 Basic example", " 19 working with Las files Log ASCII Standard (LAS) files are used for borehole data such as geophysical, geological, or petrophysical logs. lasio is a Python 3 package to read and write Las files. The best way to install lasio is using pip. pip install lasio 19.1 Basic example import lasio las = lasio.read(\"Well-1.las\") "],["rough.html", "20 rough", " 20 rough "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
